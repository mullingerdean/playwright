<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; object-src 'none';"> -->
    <title>Enhanced Playwright to Azure DevOps Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #drop-zone {
            transition: all 0.2s ease-in-out;
        }
        #drop-zone.drag-over {
            background-color: #e0f2fe;
            border-color: #0284c7;
            transform: scale(1.02);
        }
        .progress-bar {
            transition: width 0.3s ease;
        }
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .flow-visualization-surface {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.18), rgba(99, 102, 241, 0.18));
        }
        .flow-visualization-canvas {
            position: relative;
            width: 100%;
            min-height: 240px;
        }
        .flow-visualization-canvas svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        .flow-visualization-node-title {
            font-size: 14px;
            font-weight: 600;
            fill: #0f172a;
        }
        .flow-visualization-node-role {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            fill: #64748b;
        }
        .flow-visualization-node-index {
            font-size: 12px;
            font-weight: 700;
            fill: #fff;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-blue-50 min-h-screen font-sans">
    <div class="container mx-auto p-6 max-w-6xl">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-slate-900 mb-2">Playwright Test Converter</h1>
            <p class="text-slate-600 text-lg">Transform Playwright test files into Azure DevOps test case CSV files</p>
            <div class="mt-4 flex justify-center gap-4 text-sm text-slate-500">
                <span class="bg-slate-100 px-3 py-1 rounded-full">âœ¨ Enhanced Parsing</span>
                <span class="bg-slate-100 px-3 py-1 rounded-full">ðŸ”’ Secure Processing</span>
                <span class="bg-slate-100 px-3 py-1 rounded-full">ðŸ“Š Detailed Reports</span>
            </div>
        </header>

        <section class="mb-6">
            <div class="bg-white shadow rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-sm font-semibold text-slate-700">Workflow Progress</h2>
                    <div class="flex items-center gap-3">
                        <span id="workflow-progress-percent" class="text-xs text-slate-500">0%</span>
                        <button type="button" class="text-xs text-rose-600 hover:text-rose-700 font-semibold" data-action="start-over">Start Over</button>
                    </div>
                </div>
                <div class="h-2 bg-slate-200 rounded-full overflow-hidden mb-3">
                    <div id="workflow-progress-bar" class="h-2 bg-blue-600 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div class="grid grid-cols-4 text-xs text-slate-400">
                    <div data-workflow-stage="selection" class="text-left">Select Files</div>
                    <div data-workflow-stage="analysis" class="text-center">Analyze</div>
                    <div data-workflow-stage="ready" class="text-center">Review</div>
                    <div data-workflow-stage="exported" class="text-right">Export</div>
                </div>
            </div>
        </section>

        <section class="mb-6">
            <div id="drop-zone" class="bg-white shadow rounded-lg p-6 text-center border-2 border-dashed border-slate-200 cursor-pointer">
                <h3 class="text-base font-semibold text-slate-800 mb-1">Drop folders or files here</h3>
                <p class="text-sm text-slate-500">Weâ€™ll analyze Playwright specs, flows, and API helpers automatically.</p>
            </div>
            <div class="mt-4 flex flex-wrap gap-3">
                <button id="browse-folder-button" type="button" class="px-4 py-2 bg-blue-600 text-white text-sm font-semibold rounded-lg shadow-sm hover:bg-blue-700 transition-colors">Browse Folders</button>
                <button id="browse-files-button" type="button" class="px-4 py-2 bg-slate-200 text-slate-700 text-sm font-semibold rounded-lg shadow-sm hover:bg-slate-300 transition-colors">Browse Files</button>
            </div>
        </section>

        <section id="folder-selection" class="hidden mb-6">
            <div class="bg-white shadow rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-slate-700">Selected Sources</h3>
                    <button type="button" class="text-xs text-rose-600 hover:text-rose-700" data-action="start-over">Clear All</button>
                </div>
                <div id="folder-list" class="space-y-3"></div>
                <div class="mt-4 flex justify-end">
                    <button id="analyze-folders" type="button" class="px-4 py-2 bg-emerald-600 text-white text-sm font-semibold rounded-lg shadow-sm hover:bg-emerald-700 transition-colors" disabled>Analyze Selection</button>
                </div>
            </div>
        </section>

        <section id="folder-ordering" class="hidden mb-6">
            <div class="bg-white shadow rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-slate-700">Workflow Ordering</h3>
                    <button type="button" class="text-xs text-blue-600 hover:text-blue-700" data-action="reset-order">Reset Order</button>
                </div>
                <div id="ordering-list" class="space-y-3"></div>
            </div>
        </section>

        <section id="flow-visualization" class="hidden mb-6">
            <div class="bg-white shadow rounded-lg p-4 flow-visualization-surface">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-slate-700">Workflow Map</h3>
                    <span class="text-xs text-slate-500">Visual sequence of selected folders</span>
                </div>
                <div id="flow-visualization-canvas" class="flow-visualization-canvas bg-white rounded-lg"></div>
            </div>
        </section>

        <section class="mb-6">
            <div id="progress-container" class="hidden bg-white shadow rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-slate-700">Analysis Progress</h3>
                    <span id="progress-text" class="text-xs text-slate-500">0%</span>
                </div>
                <div class="h-2 bg-slate-200 rounded-full overflow-hidden">
                    <div id="progress-bar" class="h-2 bg-blue-600 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>
        </section>

        <section id="ai-settings" class="mb-6">
            <div class="bg-white shadow rounded-lg p-4">
                <div class="flex flex-col md:flex-row md:items-start md:justify-between gap-3 mb-4">
                    <div>
                        <h3 class="text-sm font-semibold text-slate-700">AI Assistant Settings</h3>
                        <p class="text-sm text-slate-500">Select your preferred provider and store a personal API key locally to enable AI-powered test reviews.</p>
                    </div>
                    <div class="text-xs text-slate-400">Optional configuration</div>
                </div>
                <div class="grid gap-4 md:grid-cols-3">
                    <div class="space-y-2">
                        <label for="ai-provider-select" class="text-xs uppercase tracking-wide text-slate-500">Provider</label>
                        <select id="ai-provider-select" class="w-full border border-slate-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none"></select>
                        <div id="ai-provider-hint" class="text-xs text-slate-500"></div>
                    </div>
                    <div class="space-y-2 md:col-span-1">
                        <label for="ai-provider-key" class="text-xs uppercase tracking-wide text-slate-500">API Key</label>
                        <div class="relative">
                            <input id="ai-provider-key" type="password" class="w-full border border-slate-200 rounded-lg px-3 py-2 pr-12 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="Paste your API key" autocomplete="off" spellcheck="false">
                            <button id="ai-toggle-key-visibility" type="button" class="absolute inset-y-0 right-2 px-2 text-xs font-semibold text-slate-500 hover:text-slate-700">Show</button>
                        </div>
                        <div id="ai-key-storage-hint" class="text-xs text-slate-500">Keys are stored locally for this user profile.</div>
                    </div>
                    <div id="ai-provider-endpoint-group" class="space-y-2 hidden md:col-span-1">
                        <label for="ai-provider-endpoint" class="text-xs uppercase tracking-wide text-slate-500" id="ai-provider-endpoint-label">Endpoint URL</label>
                        <input id="ai-provider-endpoint" type="text" class="w-full border border-slate-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="https://your-endpoint.example.com" autocomplete="off" spellcheck="false">
                        <div class="text-xs text-slate-500">Only required for providers that need an endpoint URL.</div>
                    </div>
                </div>
                <div class="grid gap-4 md:grid-cols-3 mt-4">
                    <div class="space-y-2 md:col-span-2">
                        <label for="ai-service-url" class="text-xs uppercase tracking-wide text-slate-500">Evaluation Service URL</label>
                        <input id="ai-service-url" type="text" class="w-full border border-slate-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="http://localhost:5173" autocomplete="off" spellcheck="false">
                        <div class="text-xs text-slate-500">Requests are sent to this companion service (e.g., Express backend) which relays calls to your provider.</div>
                    </div>
                    <div class="flex flex-col md:items-end gap-2">
                        <button id="ai-save-settings" type="button" class="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-600 text-white hover:bg-blue-700 transition-colors">Save Settings</button>
                        <button id="ai-clear-key" type="button" class="px-4 py-2 text-sm font-semibold rounded-lg bg-slate-200 text-slate-700 hover:bg-slate-300 transition-colors">Remove Stored Key</button>
                        <div id="ai-settings-feedback" class="text-xs text-slate-500"></div>
                    </div>
                </div>
            </div>
        </section>

        <section id="results" class="hidden mb-10">
            <div class="bg-white shadow rounded-lg p-4">
                <div id="results-content"></div>
            </div>
        </section>

        <div id="status" class="mt-4 text-sm text-slate-600"></div>
    </div>

    <div id="config-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-slate-900/40 backdrop-blur-sm pointer-events-none">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-lg p-6 relative">
            <h3 class="text-lg font-semibold text-slate-800 mb-4">Export Settings</h3>
            <div class="space-y-4">
                <div>
                    <label for="save-path-display" class="text-xs uppercase tracking-wide text-slate-500">Save Location</label>
                    <div class="mt-1 flex gap-3">
                        <input id="save-path-display" type="text" class="flex-1 border border-slate-200 rounded px-3 py-2 text-sm" readonly>
                        <button id="browse-save-location" type="button" class="px-3 py-2 text-sm font-semibold rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition-colors">Browseâ€¦</button>
                    </div>
                </div>
                <div class="flex justify-end gap-2 pt-2">
                    <button id="config-cancel" type="button" class="px-4 py-2 text-sm font-semibold rounded-lg text-slate-600 hover:text-slate-800">Cancel</button>
                    <button id="config-save" type="button" class="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-600 text-white hover:bg-blue-700 transition-colors">Export CSV</button>
                </div>
            </div>
        </div>
    </div>

    <div id="preview-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-slate-900/40 backdrop-blur-sm pointer-events-none">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-4xl max-h-[85vh] flex flex-col">
            <div class="flex items-start justify-between px-6 py-4 border-b border-slate-200 gap-3">
                <div>
                    <div class="text-xs uppercase tracking-wide text-slate-400" id="preview-modal-subtitle">Test Case Preview</div>
                    <h3 id="preview-modal-title" class="text-lg font-semibold text-slate-800"></h3>
                </div>
                <div class="flex items-center gap-3">
                    <button id="preview-run-ai" type="button" class="px-3 py-2 text-xs font-semibold rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 disabled:bg-slate-200 disabled:text-slate-400 transition-colors">Run AI Evaluation</button>
                    <button id="preview-modal-close" type="button" class="text-slate-500 hover:text-slate-700 transition-colors" aria-label="Close preview">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
            </div>
            <div id="preview-modal-status" class="hidden px-6 py-3 border-b border-slate-200 bg-slate-50 text-sm"></div>
            <div id="preview-modal-content" class="px-6 py-4 overflow-y-auto bg-slate-50 flex-1"></div>
            <div class="px-6 py-3 border-t border-slate-200 bg-white flex justify-end">
                <button id="preview-modal-dismiss" type="button" class="px-4 py-2 text-sm font-semibold rounded-lg bg-slate-200 text-slate-700 hover:bg-slate-300 transition-colors">Close</button>
            </div>
        </div>
    </div>

    <script>
        const ROLE_DISPLAY = {
            spec: 'Spec Tests',
            flow: 'Flow Helpers',
            api: 'API / Page Helpers',
            aux: 'Supporting'
        };
        const ROLE_OPTIONS = Object.keys(ROLE_DISPLAY);
        const MIN_SELECTIONS = 1;
        const ANALYSIS_SUPPORTED_EXTENSIONS = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];
        const ANALYSIS_MAX_FILE_SIZE = 5 * 1024 * 1024;
        let selectedFolders = [];
        let selectionSequence = 0;
        let currentParseResults = null;
        let selectedSaveDirectory = null;
        const azureConfig = {
            areaPath: '',
            assignedTo: '',
            state: 'Design'
        };
        const dropZone = document.getElementById('drop-zone');
        const statusDiv = document.getElementById('status');

        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const results = document.getElementById('results');
        const resultsContent = document.getElementById('results-content');
        const configModal = document.getElementById('config-modal');
        const previewModal = document.getElementById('preview-modal');
        const previewModalTitle = document.getElementById('preview-modal-title');
        const previewModalSubtitle = document.getElementById('preview-modal-subtitle');
        const previewModalContent = document.getElementById('preview-modal-content');
        const previewModalClose = document.getElementById('preview-modal-close');
        const previewModalDismiss = document.getElementById('preview-modal-dismiss');
        const previewRunAiButton = document.getElementById('preview-run-ai');
        const previewModalStatus = document.getElementById('preview-modal-status');
    const previewAiPanel = document.getElementById('preview-ai-panel');
        const aiSettingsSection = document.getElementById('ai-settings');
        const aiProviderSelect = document.getElementById('ai-provider-select');
        const aiProviderHint = document.getElementById('ai-provider-hint');
        const aiProviderKeyInput = document.getElementById('ai-provider-key');
    const aiKeyStorageHint = document.getElementById('ai-key-storage-hint');
        const aiToggleKeyVisibility = document.getElementById('ai-toggle-key-visibility');
        const aiProviderEndpointGroup = document.getElementById('ai-provider-endpoint-group');
        const aiProviderEndpointLabel = document.getElementById('ai-provider-endpoint-label');
        const aiProviderEndpointInput = document.getElementById('ai-provider-endpoint');
        const aiServiceUrlInput = document.getElementById('ai-service-url');
        const aiSaveSettingsButton = document.getElementById('ai-save-settings');
        const aiClearKeyButton = document.getElementById('ai-clear-key');
        const aiSettingsFeedback = document.getElementById('ai-settings-feedback');
        const workflowProgressBar = document.getElementById('workflow-progress-bar');
        const workflowProgressPercent = document.getElementById('workflow-progress-percent');
        const workflowStageLabels = Array.from(document.querySelectorAll('[data-workflow-stage]'));
        const folderSelection = document.getElementById('folder-selection');
        const folderList = document.getElementById('folder-list');
    const analyzeFoldersButton = document.getElementById('analyze-folders');
    const startOverButtons = Array.from(document.querySelectorAll('[data-action="start-over"]'));
    const orderingPanel = document.getElementById('folder-ordering');
    const orderingList = document.getElementById('ordering-list');
    const resetOrderButton = orderingPanel ? orderingPanel.querySelector('[data-action="reset-order"]') : null;
        const flowVisualization = document.getElementById('flow-visualization');
        const flowVisualizationCanvas = document.getElementById('flow-visualization-canvas');

    let previewModalInitialized = false;
    let activePreviewTestCaseIndex = null;
        const AI_CONFIG_STORAGE_KEY = 'playwrightConverter.aiSettings.v1';
        const DEFAULT_AI_SERVICE_URL = 'http://localhost:5173';
        const AI_PROVIDERS = [
            {
                id: 'openai',
                label: 'OpenAI (GPT-4o / GPT-4o mini)',
                keyPlaceholder: 'sk-... (OpenAI API key)',
                docsUrl: 'https://platform.openai.com/docs/overview',
                requiresEndpoint: false
            },
            {
                id: 'anthropic',
                label: 'Anthropic Claude',
                keyPlaceholder: 'sk-ant-... (Anthropic API key)',
                docsUrl: 'https://docs.anthropic.com/claude/reference',
                requiresEndpoint: false
            },
            {
                id: 'gemini',
                label: 'Google Gemini (AI Studio key)',
                keyPlaceholder: 'AIza... (Google AI Studio API key)',
                docsUrl: 'https://ai.google.dev/gemini-api/docs',
                requiresEndpoint: false
            },
            {
                id: 'azure-openai',
                label: 'Azure OpenAI Service',
                keyPlaceholder: 'Azure OpenAI API key',
                docsUrl: 'https://learn.microsoft.com/azure/ai-services/openai/',
                requiresEndpoint: true,
                endpointLabel: 'Resource Endpoint',
                endpointPlaceholder: 'https://your-resource.openai.azure.com'
            },
            {
                id: 'custom-http',
                label: 'Custom HTTP Provider',
                keyPlaceholder: 'Bearer token or API key',
                docsUrl: '',
                requiresEndpoint: true,
                endpointLabel: 'Custom Endpoint URL',
                endpointPlaceholder: 'https://your-service.example.com/v1/evaluate'
            }
        ];
        const PREVIEW_STATUS_BASE_CLASSES = 'px-6 py-3 border-b text-sm';
        const PREVIEW_STATUS_TONES = {
            info: 'border-slate-200 bg-slate-50 text-slate-600',
            success: 'border-emerald-200 bg-emerald-50 text-emerald-700',
            warning: 'border-amber-200 bg-amber-50 text-amber-700',
            error: 'border-rose-200 bg-rose-50 text-rose-700'
        };
        let aiSettings = null;
        let aiEvaluationInFlight = false;
        let aiSettingsFeedbackTimer = null;
    let secureStorageAvailable = false;
    const providerKeyCache = {};
    let latestAiEvaluationResult = null;
    let latestAiEvaluationTestCaseTitle = '';

        const WORKFLOW_SEQUENCE = ['start', 'selection', 'analysis', 'ready', 'exported'];
        const WORKFLOW_PROGRESS = {
            start: 0,
            selection: 40,
            analysis: 70,
            ready: 95,
            exported: 100
        };
        let currentWorkflowStage = 'start';

        // File input for browse functionality
        let fileInput = null;

        const createFileInput = (mode = 'folder') => {
            fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.multiple = true;
            if (mode === 'folder') {
                fileInput.webkitdirectory = true;
            }
            fileInput.dataset.mode = mode;
            fileInput.addEventListener('change', async (e) => {
                document.body.removeChild(fileInput);
                fileInput = null;
                await handleFileSelection(e, mode);
            });
            document.body.appendChild(fileInput);
            return fileInput;
        };

        function createDefaultAiSettings() {
            const providerState = {};
            AI_PROVIDERS.forEach(provider => {
                providerState[provider.id] = {
                    apiKey: '',
                    endpoint: ''
                };
            });
            return {
                providerId: AI_PROVIDERS[0]?.id || 'openai',
                serviceUrl: DEFAULT_AI_SERVICE_URL,
                providers: providerState
            };
        }

        function mergeAiSettings(base, incoming) {
            const result = Object.assign({}, base, incoming || {});
            result.providers = Object.assign({}, base.providers);
            if (incoming && typeof incoming.providers === 'object') {
                Object.keys(incoming.providers).forEach(key => {
                    const baseEntry = base.providers[key] || { apiKey: '', endpoint: '' };
                    const incomingEntry = incoming.providers[key] || {};
                    result.providers[key] = Object.assign({}, baseEntry, incomingEntry);
                });
            }
            if (!result.providerId || !AI_PROVIDERS.some(provider => provider.id === result.providerId)) {
                result.providerId = base.providerId;
            }
            if (!result.serviceUrl) {
                result.serviceUrl = base.serviceUrl;
            }
            return result;
        }

        function loadAiSettingsFromStorage() {
            const defaults = createDefaultAiSettings();
            if (typeof localStorage === 'undefined') {
                return defaults;
            }
            try {
                const raw = localStorage.getItem(AI_CONFIG_STORAGE_KEY);
                if (!raw) {
                    return defaults;
                }
                const parsed = JSON.parse(raw);
                return mergeAiSettings(defaults, parsed);
            } catch (error) {
                console.warn('Failed to parse AI settings from storage:', error);
                return defaults;
            }
        }

        function saveAiSettingsToStorage(settings) {
            if (typeof localStorage === 'undefined') {
                return;
            }
            try {
                const sanitized = JSON.stringify(settings, (key, value) => {
                    if (key === 'apiKey' && secureStorageAvailable) {
                        return undefined;
                    }
                    return value;
                });
                localStorage.setItem(AI_CONFIG_STORAGE_KEY, sanitized);
            } catch (error) {
                console.warn('Unable to persist AI settings:', error);
            }
        }

        async function detectSecureStorageAvailability() {
            if (!window.electronAPI || !window.electronAPI.aiCredentials || typeof window.electronAPI.aiCredentials.isAvailable !== 'function') {
                secureStorageAvailable = false;
            } else {
                try {
                    const result = await window.electronAPI.aiCredentials.isAvailable();
                    secureStorageAvailable = !!(result && result.available);
                } catch (error) {
                    console.warn('Failed to detect secure storage availability:', error);
                    secureStorageAvailable = false;
                }
            }

            if (aiKeyStorageHint) {
                aiKeyStorageHint.textContent = secureStorageAvailable
                    ? 'Keys are stored securely in your operating system keychain.'
                    : 'Secure storage unavailable; keys are stored locally for this profile.';
            }

            return secureStorageAvailable;
        }

        function markSecureStorageUnavailable() {
            secureStorageAvailable = false;
            if (aiKeyStorageHint) {
                aiKeyStorageHint.textContent = 'Secure storage unavailable; keys are stored locally for this profile.';
            }
        }

        function getCachedProviderKey(providerId) {
            if (!providerId) return '';
            return providerKeyCache.hasOwnProperty(providerId) ? providerKeyCache[providerId] : '';
        }

        async function loadProviderKey(providerId) {
            if (!providerId) {
                return '';
            }

            if (providerKeyCache.hasOwnProperty(providerId)) {
                return providerKeyCache[providerId];
            }

            let key = '';
            if (secureStorageAvailable && window.electronAPI?.aiCredentials?.load) {
                try {
                    const result = await window.electronAPI.aiCredentials.load(providerId);
                    if (result && result.success) {
                        key = result.apiKey || '';
                    } else if (aiSettings?.providers?.[providerId]) {
                        key = aiSettings.providers[providerId].apiKey || '';
                    }
                } catch (error) {
                    console.warn(`Failed to load key for provider ${providerId}:`, error);
                    markSecureStorageUnavailable();
                    key = aiSettings?.providers?.[providerId]?.apiKey || '';
                }
            } else {
                const providerState = aiSettings?.providers?.[providerId];
                key = providerState?.apiKey || '';
            }

            providerKeyCache[providerId] = key || '';
            return providerKeyCache[providerId];
        }

        async function persistProviderKey(providerId, apiKey) {
            if (!providerId) {
                return { success: false, message: 'Provider ID is required.' };
            }

            const trimmedKey = (apiKey || '').trim();

            if (secureStorageAvailable && window.electronAPI?.aiCredentials?.save) {
                try {
                    const result = await window.electronAPI.aiCredentials.save(providerId, trimmedKey);
                    if (!result || !result.success) {
                        console.warn('Secure storage save failed, falling back to local persistence:', result);
                        markSecureStorageUnavailable();
                    } else {
                        providerKeyCache[providerId] = trimmedKey;
                        return { success: true, secure: true };
                    }
                } catch (error) {
                    console.error('Error saving key to secure storage:', error);
                    markSecureStorageUnavailable();
                }
            }

            if (!aiSettings.providers[providerId]) {
                aiSettings.providers[providerId] = { apiKey: '', endpoint: '' };
            }
            aiSettings.providers[providerId].apiKey = trimmedKey;
            providerKeyCache[providerId] = trimmedKey;
            return {
                success: true,
                secure: false,
                message: secureStorageAvailable
                    ? 'Stored locally because secure storage was unavailable.'
                    : 'Stored in local settings.'
            };
        }

        async function clearProviderKey(providerId) {
            if (!providerId) {
                return { success: false, message: 'Provider ID is required.' };
            }

            let clearedSecurely = false;

            if (secureStorageAvailable && window.electronAPI?.aiCredentials?.clear) {
                try {
                    const result = await window.electronAPI.aiCredentials.clear(providerId);
                    if (!result || !result.success) {
                        console.warn('Secure storage removal failed, falling back to local clearance:', result);
                        markSecureStorageUnavailable();
                    } else {
                        clearedSecurely = true;
                    }
                } catch (error) {
                    console.error('Error removing key from secure storage:', error);
                    markSecureStorageUnavailable();
                }
            }

            if (aiSettings.providers[providerId]) {
                aiSettings.providers[providerId].apiKey = '';
            }

            providerKeyCache[providerId] = '';
            return {
                success: true,
                secure: clearedSecurely,
                message: clearedSecurely ? undefined : 'Secure storage unavailable; cleared local key copy instead.'
            };
        }

        function getAiProviderById(id) {
            return AI_PROVIDERS.find(provider => provider.id === id) || AI_PROVIDERS[0];
        }

        async function initializeAiAssistantSettings() {
            aiSettings = loadAiSettingsFromStorage();
            populateAiProviderSelect();
            await detectSecureStorageAvailability();
            await applyAiSettingsToUi();
        }

        function populateAiProviderSelect() {
            if (!aiProviderSelect) {
                return;
            }
            if (!aiProviderSelect.options || aiProviderSelect.options.length === 0) {
                aiProviderSelect.innerHTML = AI_PROVIDERS.map(provider => `<option value="${provider.id}">${provider.label}</option>`).join('');
            }
        }

        async function applyAiSettingsToUi() {
            if (!aiSettings) {
                aiSettings = createDefaultAiSettings();
            }
            const provider = getAiProviderById(aiSettings.providerId);
            if (aiProviderSelect) {
                aiProviderSelect.value = provider.id;
            }
            updateAiProviderUi(provider);
            if (aiServiceUrlInput) {
                aiServiceUrlInput.value = aiSettings.serviceUrl || '';
            }
            const providerState = aiSettings.providers?.[provider.id] || { apiKey: '', endpoint: '' };
            if (aiProviderEndpointInput) {
                aiProviderEndpointInput.value = providerState.endpoint || '';
            }
            const key = await loadProviderKey(provider.id);
            if (aiProviderKeyInput) {
                aiProviderKeyInput.value = key || '';
            }
            updateAiEvaluationButtonState();
        }

        function updateAiProviderUi(provider) {
            if (!provider) {
                provider = getAiProviderById(aiSettings?.providerId || AI_PROVIDERS[0].id);
            }
            if (aiProviderHint) {
                const docLink = provider.docsUrl
                    ? ` Â· <a href="${provider.docsUrl}" target="_blank" rel="noreferrer" class="text-blue-600 hover:text-blue-700">Docs</a>`
                    : '';
                aiProviderHint.innerHTML = `${provider.label}${docLink}`;
            }
            if (aiProviderKeyInput) {
                aiProviderKeyInput.placeholder = provider.keyPlaceholder || 'Enter API key';
            }
            if (aiProviderEndpointGroup) {
                if (provider.requiresEndpoint) {
                    aiProviderEndpointGroup.classList.remove('hidden');
                    if (aiProviderEndpointLabel) {
                        aiProviderEndpointLabel.textContent = provider.endpointLabel || 'Endpoint URL';
                    }
                    if (aiProviderEndpointInput) {
                        aiProviderEndpointInput.placeholder = provider.endpointPlaceholder || 'https://your-endpoint.example.com';
                    }
                } else {
                    aiProviderEndpointGroup.classList.add('hidden');
                }
            }
        }

        async function handleAiProviderChange() {
            if (!aiSettings) {
                aiSettings = createDefaultAiSettings();
            }
            const selectedId = aiProviderSelect?.value || aiSettings.providerId;
            aiSettings.providerId = selectedId;
            const provider = getAiProviderById(selectedId);
            updateAiProviderUi(provider);
            const providerState = aiSettings.providers?.[selectedId] || { apiKey: '', endpoint: '' };
            if (aiProviderEndpointInput) {
                aiProviderEndpointInput.value = providerState.endpoint || '';
            }
            const key = await loadProviderKey(selectedId);
            if (aiProviderKeyInput) {
                aiProviderKeyInput.value = key || '';
            }
            saveAiSettingsToStorage(aiSettings);
            updateAiEvaluationButtonState();
        }

        function handleAiToggleKeyVisibility() {
            if (!aiProviderKeyInput || !aiToggleKeyVisibility) {
                return;
            }
            const isPassword = aiProviderKeyInput.type === 'password';
            aiProviderKeyInput.type = isPassword ? 'text' : 'password';
            aiToggleKeyVisibility.textContent = isPassword ? 'Hide' : 'Show';
        }

        function showAiSettingsFeedback(message, tone = 'info') {
            if (!aiSettingsFeedback) {
                return;
            }
            const toneClasses = {
                success: 'text-emerald-600',
                warning: 'text-amber-600',
                error: 'text-rose-600',
                info: 'text-slate-500'
            };
            aiSettingsFeedback.textContent = message;
            aiSettingsFeedback.className = `text-xs ${toneClasses[tone] || toneClasses.info}`;
            if (aiSettingsFeedbackTimer) {
                clearTimeout(aiSettingsFeedbackTimer);
            }
            aiSettingsFeedbackTimer = setTimeout(() => {
                aiSettingsFeedback.textContent = '';
            }, 4000);
        }

        async function handleAiSaveSettings() {
            if (!aiSettings) {
                aiSettings = createDefaultAiSettings();
            }
            const providerId = aiProviderSelect?.value || aiSettings.providerId;
            aiSettings.providerId = providerId;
            if (aiServiceUrlInput) {
                aiSettings.serviceUrl = (aiServiceUrlInput.value || '').trim();
            }
            if (!aiSettings.providers[providerId]) {
                aiSettings.providers[providerId] = { apiKey: '', endpoint: '' };
            }
            if (aiProviderEndpointInput) {
                aiSettings.providers[providerId].endpoint = (aiProviderEndpointInput.value || '').trim();
            }
            const keyValue = aiProviderKeyInput ? aiProviderKeyInput.value : '';
            const keyResult = await persistProviderKey(providerId, keyValue);
            let feedbackMessage = 'AI settings saved.';
            let feedbackTone = 'success';

            if (!keyResult || keyResult.success === false) {
                feedbackMessage = keyResult?.message || 'Error saving API key.';
                feedbackTone = 'error';
            } else if (!keyResult.secure) {
                feedbackMessage = keyResult.message || 'API key saved locally (secure storage unavailable).';
                feedbackTone = secureStorageAvailable ? 'warning' : 'info';
            } else if (keyResult.message) {
                feedbackMessage = keyResult.message;
                feedbackTone = 'info';
            }

            showAiSettingsFeedback(feedbackMessage, feedbackTone);
            if (secureStorageAvailable && aiSettings.providers[providerId]) {
                aiSettings.providers[providerId].apiKey = '';
            }
            saveAiSettingsToStorage(aiSettings);
            updateAiEvaluationButtonState();
        }

        async function handleAiClearKey() {
            if (!aiSettings) {
                aiSettings = createDefaultAiSettings();
            }
            const providerId = aiProviderSelect?.value || aiSettings.providerId;
            if (!aiSettings.providers[providerId]) {
                aiSettings.providers[providerId] = { apiKey: '', endpoint: '' };
            }
            const result = await clearProviderKey(providerId);
            if (aiProviderKeyInput) {
                aiProviderKeyInput.value = '';
            }
            let feedbackMessage = 'Stored key removed for selected provider.';
            let feedbackTone = 'info';
            if (!result || result.success === false) {
                feedbackMessage = result?.message || 'Error clearing stored key.';
                feedbackTone = 'error';
            } else if (!result.secure) {
                feedbackMessage = result.message || 'Secure storage unavailable; cleared local key copy instead.';
                feedbackTone = secureStorageAvailable ? 'warning' : 'info';
            }
            showAiSettingsFeedback(feedbackMessage, feedbackTone);
            if (secureStorageAvailable) {
                aiSettings.providers[providerId].apiKey = '';
            }
            saveAiSettingsToStorage(aiSettings);
            updateAiEvaluationButtonState();
        }

        async function getActiveProviderConfig() {
            if (!aiSettings) {
                aiSettings = createDefaultAiSettings();
            }
            const providerId = aiSettings.providerId || AI_PROVIDERS[0].id;
            const providerState = aiSettings.providers?.[providerId] || { apiKey: '', endpoint: '' };
            const apiKey = await loadProviderKey(providerId);
            return {
                provider: getAiProviderById(providerId),
                providerId,
                apiKey: (apiKey || '').trim(),
                endpoint: (providerState.endpoint || '').trim(),
                serviceUrl: (aiSettings.serviceUrl || '').trim()
            };
        }

        function updateAiEvaluationButtonState() {
            if (!previewRunAiButton) {
                return;
            }
            const providerId = aiSettings?.providerId || AI_PROVIDERS[0].id;
            const cachedKey = (getCachedProviderKey(providerId) || '').trim();
            const serviceUrl = (aiSettings?.serviceUrl || '').trim();
            const hasConfig = cachedKey && serviceUrl;
            previewRunAiButton.disabled = !hasConfig || aiEvaluationInFlight;
        }

        function setPreviewModalStatus(message, tone = 'info') {
            if (!previewModalStatus) {
                return;
            }
            const toneClasses = PREVIEW_STATUS_TONES[tone] || PREVIEW_STATUS_TONES.info;
            previewModalStatus.className = `${PREVIEW_STATUS_BASE_CLASSES} ${toneClasses}`;
            previewModalStatus.classList.remove('hidden');
            previewModalStatus.textContent = message;
        }

        function clearPreviewModalStatus() {
            if (!previewModalStatus) {
                return;
            }
            previewModalStatus.className = `${PREVIEW_STATUS_BASE_CLASSES} ${PREVIEW_STATUS_TONES.info}`;
            previewModalStatus.classList.add('hidden');
            previewModalStatus.textContent = '';
        }

        function buildAiEvaluationPayload(testCase) {
            if (!testCase) {
                return null;
            }
            const sanitizedSteps = Array.isArray(testCase.steps)
                ? testCase.steps.map((step, index) => ({
                    index: index + 1,
                    action: step?.action || '',
                    expectedResult: step?.expectedResult || '',
                    context: step?.context || null
                }))
                : [];
            return {
                title: testCase.title || 'Untitled test case',
                metadata: {
                    sourceFile: testCase.sourceFile || testCase.filePath || null,
                    tags: Array.isArray(testCase.tags) ? testCase.tags : [],
                    helperCount: Array.isArray(testCase.supportingContext?.apis) ? testCase.supportingContext.apis.length : 0
                },
                steps: sanitizedSteps,
                supportingContext: testCase.supportingContext || null
            };
        }

        function getLatestComprehensivePlan() {
            if (!latestAiEvaluationResult) {
                return null;
            }
            return latestAiEvaluationResult.comprehensive_plan
                || latestAiEvaluationResult.comprehensivePlan
                || null;
        }

        function slugifyForFileName(value) {
            if (!value) {
                return 'test-plan';
            }
            return value
                .toString()
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '')
                .slice(0, 80) || 'test-plan';
        }

        function sanitizeMarkdown(value) {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value)
                .replace(/\r\n/g, '\n')
                .replace(/\r/g, '\n');
        }

        function buildPlanMarkdown(plan) {
            if (!plan) {
                return '';
            }

            const lines = [];
            lines.push(`# Test Plan: ${sanitizeMarkdown(plan.title || 'Test Case')}`);
            lines.push('');
            if (plan.summary) {
                lines.push(sanitizeMarkdown(plan.summary));
                lines.push('');
            }

            const coverageEntries = plan.coverage ? Object.entries(plan.coverage) : [];
            if (coverageEntries.length > 0) {
                lines.push('## Coverage Overview');
                coverageEntries.forEach(([key, value]) => {
                    lines.push(`- **${sanitizeMarkdown(key)}:** ${sanitizeMarkdown(value)}`);
                });
                lines.push('');
            }

            if (Array.isArray(plan.functionalHighlights) && plan.functionalHighlights.length > 0) {
                lines.push('## Functional Highlights');
                plan.functionalHighlights.forEach(item => {
                    lines.push(`- ${sanitizeMarkdown(item)}`);
                });
                lines.push('');
            }

            if (plan.spec && Array.isArray(plan.spec.steps) && plan.spec.steps.length > 0) {
                lines.push('## Spec Coverage');
                plan.spec.steps.forEach(step => {
                    const indexLabel = step.index != null ? `Step ${step.index}` : 'Step';
                    lines.push(`### ${sanitizeMarkdown(indexLabel)} â€” ${sanitizeMarkdown(step.headline || '')}`);
                    if (step.action) {
                        lines.push('**Action**');
                        lines.push('');
                        lines.push(sanitizeMarkdown(step.action));
                        lines.push('');
                    }
                    if (step.expectedResult) {
                        lines.push('**Expected Result**');
                        lines.push('');
                        lines.push(sanitizeMarkdown(step.expectedResult));
                        lines.push('');
                    }
                });
            }

            if (Array.isArray(plan.flows) && plan.flows.length > 0) {
                lines.push('## Flow Helper Coverage');
                plan.flows.forEach(flow => {
                    lines.push(`### ${sanitizeMarkdown(flow.label || 'Flow helper')}`);
                    if (flow.summary) {
                        lines.push(sanitizeMarkdown(flow.summary));
                        lines.push('');
                    }
                    if (Array.isArray(flow.invokedMethods) && flow.invokedMethods.length > 0) {
                        lines.push('**Methods**');
                        flow.invokedMethods.forEach(method => {
                            lines.push(`- ${sanitizeMarkdown(method.methodName || 'Method')} ${method.summaryText ? `â€” ${sanitizeMarkdown(method.summaryText)}` : ''}`);
                        });
                        lines.push('');
                    }
                    if (Array.isArray(flow.httpCalls) && flow.httpCalls.length > 0) {
                        lines.push('**HTTP Calls**');
                        flow.httpCalls.forEach(call => {
                            lines.push(`- ${sanitizeMarkdown((call.method || '').toUpperCase())} ${sanitizeMarkdown(call.url || '(dynamic URL)')}`);
                        });
                        lines.push('');
                    }
                    if (Array.isArray(flow.sqlQueries) && flow.sqlQueries.length > 0) {
                        lines.push('**SQL Queries**');
                        flow.sqlQueries.forEach(query => {
                            lines.push('```sql');
                            lines.push(sanitizeMarkdown(query.query || query));
                            lines.push('```');
                        });
                        lines.push('');
                    }
                });
            }

            if (Array.isArray(plan.apis) && plan.apis.length > 0) {
                lines.push('## API Helper Coverage');
                plan.apis.forEach(api => {
                    lines.push(`### ${sanitizeMarkdown(api.label || 'API helper')}`);
                    if (api.summary) {
                        lines.push(sanitizeMarkdown(api.summary));
                        lines.push('');
                    }
                    if (api.endpoint) {
                        lines.push(`- **Endpoint:** ${sanitizeMarkdown(api.endpoint)}`);
                    }
                    if (Array.isArray(api.methods) && api.methods.length > 0) {
                        lines.push('- **Methods:**');
                        api.methods.forEach(method => {
                            lines.push(`  - ${sanitizeMarkdown(method.methodName || 'Method')} ${method.summaryText ? `â€” ${sanitizeMarkdown(method.summaryText)}` : ''}`);
                        });
                    }
                    if (Array.isArray(api.httpCalls) && api.httpCalls.length > 0) {
                        lines.push('- **HTTP Calls:**');
                        api.httpCalls.forEach(call => {
                            lines.push(`  - ${sanitizeMarkdown((call.method || '').toUpperCase())} ${sanitizeMarkdown(call.url || '(dynamic URL)')}`);
                        });
                    }
                    if (Array.isArray(api.exports) && api.exports.length > 0) {
                        lines.push(`- **Exports:** ${sanitizeMarkdown(api.exports.join(', '))}`);
                    }
                    if (Array.isArray(api.sqlQueries) && api.sqlQueries.length > 0) {
                        lines.push('- **SQL Queries:**');
                        api.sqlQueries.forEach(query => {
                            lines.push('  ```sql');
                            lines.push(`  ${sanitizeMarkdown(query.query || query)}`);
                            lines.push('  ```');
                        });
                    }
                    lines.push('');
                });
            }

            if (Array.isArray(plan.httpCalls) && plan.httpCalls.length > 0) {
                lines.push('## HTTP Coverage');
                plan.httpCalls.forEach(call => {
                    lines.push(`- ${sanitizeMarkdown((call.method || '').toUpperCase())} ${sanitizeMarkdown(call.url || '(dynamic URL)')}`);
                    if (Array.isArray(call.sources) && call.sources.length > 0) {
                        lines.push(`  - Sources: ${sanitizeMarkdown(call.sources.join(', '))}`);
                    }
                    if (Array.isArray(call.payloads) && call.payloads.length > 0) {
                        lines.push(`  - Payloads: ${sanitizeMarkdown(call.payloads.join(', '))}`);
                    }
                });
                lines.push('');
            }

            if (Array.isArray(plan.sqlQueries) && plan.sqlQueries.length > 0) {
                lines.push('## Database Coverage');
                plan.sqlQueries.forEach(query => {
                    lines.push(`### Query ${sanitizeMarkdown(String(query.index || ''))}`);
                    lines.push('```sql');
                    lines.push(sanitizeMarkdown(query.query || ''));
                    lines.push('```');
                    lines.push('');
                });
            }

            return lines.join('\n');
        }

        async function exportComprehensivePlan(format = 'markdown') {
            const plan = getLatestComprehensivePlan();
            if (!plan) {
                setPreviewModalStatus('No AI plan available to export yet.', 'warning');
                return;
            }

            const safeTitle = slugifyForFileName(plan.title || latestAiEvaluationTestCaseTitle || 'test-plan');
            const baseFileName = `${safeTitle || 'test-plan'}-ai-plan`;

            let content = '';
            let extension = 'md';
            let filters = [{ name: 'Markdown', extensions: ['md'] }];
            let mimeType = 'text/markdown';

            if (format === 'json') {
                content = JSON.stringify(plan, null, 2);
                extension = 'json';
                filters = [{ name: 'JSON', extensions: ['json'] }];
                mimeType = 'application/json';
            } else {
                content = buildPlanMarkdown(plan);
            }

            if (window.electronAPI?.saveTextFile) {
                const result = await window.electronAPI.saveTextFile({
                    defaultFileName: baseFileName,
                    content,
                    extension,
                    filters
                });
                if (result && result.success) {
                    setPreviewModalStatus(`${format === 'json' ? 'JSON' : 'Markdown'} plan saved successfully.`, 'success');
                } else {
                    setPreviewModalStatus(result?.message || 'Failed to save plan.', 'error');
                }
            } else {
                try {
                    const blob = new Blob([content], { type: mimeType });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `${baseFileName}.${extension}`;
                    document.body.appendChild(link);
                    link.click();
                    setTimeout(() => {
                        URL.revokeObjectURL(link.href);
                        document.body.removeChild(link);
                    }, 0);
                    setPreviewModalStatus(`${format === 'json' ? 'JSON' : 'Markdown'} plan downloaded.`, 'success');
                } catch (error) {
                    console.error('Plan export failed:', error);
                    setPreviewModalStatus('Plan export failed. See console for details.', 'error');
                }
            }
        }

        function handlePlanExportClick(event) {
            const button = event.target.closest('[data-plan-export]');
            if (!button) {
                return;
            }
            event.preventDefault();
            const format = button.getAttribute('data-plan-export') || 'markdown';
            exportComprehensivePlan(format).catch(error => {
                console.error('Plan export failed:', error);
                setPreviewModalStatus('Plan export failed unexpectedly. See console for details.', 'error');
            });
        }

        function updateAiPreviewPanel(result) {
            const panel = document.getElementById('preview-ai-panel');
            if (!panel) {
                return;
            }
            if (!result) {
                panel.classList.add('hidden');
                panel.innerHTML = '';
                return;
            }

            panel.classList.remove('hidden');
            if (result.error) {
                panel.className = 'bg-rose-50 border border-rose-200 text-rose-700 rounded-lg p-4 text-sm space-y-2';
                panel.innerHTML = `
                    <div class="font-semibold">AI evaluation failed</div>
                    <div>${escapeHtml(result.error)}</div>
                `;
                return;
            }

            panel.className = 'bg-indigo-50 border border-indigo-200 text-indigo-800 rounded-lg p-4 text-sm space-y-4';
            const riskScoreSource = typeof result.risk_score === 'number'
                ? result.risk_score
                : (typeof result.riskScore === 'number' ? result.riskScore : null);
            const riskScore = riskScoreSource !== null ? Math.round(riskScoreSource) : null;
            const summary = escapeHtml(result.summary || result.analysis || result.message || 'AI assistant completed without a summary.');
            const missingList = Array.isArray(result.missing_assertions) && result.missing_assertions.length > 0
                ? result.missing_assertions
                : (Array.isArray(result.missingAssertions) ? result.missingAssertions : []);
            const improvementsList = Array.isArray(result.suggested_improvements) && result.suggested_improvements.length > 0
                ? result.suggested_improvements
                : (Array.isArray(result.suggestedImprovements) ? result.suggestedImprovements : []);
            const helperList = Array.isArray(result.helper_feedback) && result.helper_feedback.length > 0
                ? result.helper_feedback
                : (Array.isArray(result.helperFeedback) ? result.helperFeedback : []);
            const missingAssertions = missingList.length > 0
                ? `<ul class="list-disc list-inside space-y-1">${missingList.slice(0, 6).map(item => `<li>${escapeHtml(item)}</li>`).join('')}</ul>`
                : '<div class="text-slate-600">No missing assertions identified.</div>';
            const improvements = improvementsList.length > 0
                ? `<ul class="list-disc list-inside space-y-1">${improvementsList.slice(0, 6).map(item => `<li>${escapeHtml(item)}</li>`).join('')}</ul>`
                : '<div class="text-slate-600">No improvements suggested.</div>';
            const helperFeedback = helperList.length > 0
                ? `<div class="space-y-2">${helperList.slice(0, 4).map(item => {
                        const name = escapeHtml(item.name || 'Helper');
                        const issue = escapeHtml(item.issue || 'Observation not provided.');
                        const recommendation = escapeHtml(item.recommendation || 'Consider reviewing this helper.');
                        return `
                            <div class="bg-white/70 border border-indigo-200/60 rounded-lg p-3">
                                <div class="text-xs uppercase tracking-wide text-indigo-500">${name}</div>
                                <div class="mt-1 text-slate-700"><span class="font-semibold">Issue:</span> ${issue}</div>
                                <div class="mt-1 text-slate-700"><span class="font-semibold">Recommendation:</span> ${recommendation}</div>
                            </div>
                        `;
                    }).join('')}</div>`
                : '';

            const plan = result.comprehensive_plan || result.comprehensivePlan || null;
            let planSection = '';

            if (plan) {
                const coverage = plan.coverage || {};
                const coverageEntries = [
                    { label: 'Spec steps', value: coverage.specSteps },
                    { label: 'Flow helpers', value: coverage.flows },
                    { label: 'API integrations', value: coverage.apis },
                    { label: 'HTTP calls', value: coverage.httpCalls },
                    { label: 'SQL queries', value: coverage.sqlQueries }
                ].filter(entry => typeof entry.value === 'number' && entry.value >= 0);
                const coverageBadges = coverageEntries.length > 0
                    ? `<div class="flex flex-wrap gap-2">${coverageEntries.map(entry => `
                        <span class="inline-flex items-center px-2.5 py-1 rounded-full bg-indigo-600/10 text-indigo-700 text-xs font-semibold">
                            ${escapeHtml(String(entry.value))} ${escapeHtml(entry.label)}
                        </span>
                    `).join('')}</div>`
                    : '';

                const highlights = Array.isArray(plan.functionalHighlights) && plan.functionalHighlights.length > 0
                    ? `<ul class="list-disc list-inside space-y-1">
                        ${plan.functionalHighlights.slice(0, 6).map(item => `<li>${escapeHtml(item)}</li>`).join('')}
                    </ul>`
                    : '';

                const specSteps = Array.isArray(plan.spec?.steps) ? plan.spec.steps : [];
                const specSection = specSteps.length > 0
                    ? `<div class="space-y-2">
                        <div class="text-xs uppercase tracking-wide text-indigo-500 font-semibold">Spec Coverage</div>
                        <ol class="space-y-2">
                            ${specSteps.slice(0, 12).map(step => `
                                <li class="bg-white/70 border border-indigo-200/60 rounded-lg p-3">
                                    <div class="flex items-start justify-between gap-2">
                                        <div class="font-semibold text-indigo-900">Step ${escapeHtml(String(step.index))}: ${escapeHtml(step.headline)}</div>
                                        <span class="text-xs text-indigo-500 uppercase tracking-wide">${escapeHtml((step.source || '').replace(/-/g, ' '))}</span>
                                    </div>
                                    <div class="mt-2 text-slate-700 whitespace-pre-wrap">${escapeHtml(step.action || '')}</div>
                                    <div class="mt-2 text-slate-600 italic whitespace-pre-wrap">Expected: ${escapeHtml(step.expectedResult || 'Document expected outcomes for this step.')}</div>
                                </li>
                            `).join('')}
                        </ol>
                        ${specSteps.length > 12 ? `<div class="text-xs text-slate-500">Showing first 12 steps of ${specSteps.length}. Review source spec for full detail.</div>` : ''}
                    </div>`
                    : '';

                const renderMethodList = (methods = []) => {
                    if (!Array.isArray(methods) || methods.length === 0) {
                        return '';
                    }
                    const preview = methods.slice(0, 4).map(method => {
                        const name = method?.methodName || method?.name || 'Method';
                        const summaryText = method?.summaryText ? ` â€” ${method.summaryText}` : '';
                        return `<span>${escapeHtml(name + summaryText)}</span>`;
                    }).join('; ');
                    return `<div class="text-slate-700"><span class="font-semibold">Methods:</span> ${preview}${methods.length > 4 ? 'â€¦' : ''}</div>`;
                };

                const renderHttpList = (calls = []) => {
                    if (!Array.isArray(calls) || calls.length === 0) {
                        return '';
                    }
                    return `<div class="text-slate-700"><span class="font-semibold">HTTP:</span> ${calls.slice(0, 3).map(call => `${escapeHtml((call.method || '').toUpperCase())} ${escapeHtml(call.url || '(dynamic URL)')}`).join('; ')}${calls.length > 3 ? 'â€¦' : ''}</div>`;
                };

                const renderSqlList = (queries = []) => {
                    if (!Array.isArray(queries) || queries.length === 0) {
                        return '';
                    }
                    return `<div class="text-slate-700"><span class="font-semibold">SQL:</span> ${queries.slice(0, 3).map(query => escapeHtml(query.query || query)).join('; ')}${queries.length > 3 ? 'â€¦' : ''}</div>`;
                };

                const planActions = `
                    <div class="flex flex-wrap gap-2 mt-3">
                        <button type="button" class="px-3 py-2 text-xs font-semibold rounded bg-indigo-600 text-white hover:bg-indigo-700 transition-colors" data-plan-export="markdown">Download Plan (Markdown)</button>
                        <button type="button" class="px-3 py-2 text-xs font-semibold rounded bg-white text-indigo-600 border border-indigo-200 hover:bg-indigo-50 transition-colors" data-plan-export="json">Download Plan (JSON)</button>
                    </div>
                `;

                const flowCards = Array.isArray(plan.flows) && plan.flows.length > 0
                    ? `<div class="space-y-2">
                        <div class="text-xs uppercase tracking-wide text-indigo-500 font-semibold">Flow Helper Coverage</div>
                        <div class="space-y-3">
                            ${plan.flows.map(flow => `
                                <div class="bg-white/70 border border-indigo-200/60 rounded-lg p-3 space-y-2">
                                    <div class="font-semibold text-indigo-900">${escapeHtml(flow.label || 'Flow helper')}</div>
                                    <div class="text-slate-700">${escapeHtml(flow.summary || 'Flow orchestrates supporting actions.')}</div>
                                    ${renderMethodList(flow.invokedMethods)}
                                    ${renderHttpList(flow.httpCalls)}
                                    ${renderSqlList(flow.sqlQueries)}
                                </div>
                            `).join('')}
                        </div>
                    </div>`
                    : '';

                const apiCards = Array.isArray(plan.apis) && plan.apis.length > 0
                    ? `<div class="space-y-2">
                        <div class="text-xs uppercase tracking-wide text-indigo-500 font-semibold">API Helper Coverage</div>
                        <div class="space-y-3">
                            ${plan.apis.map(api => {
                                const exportsList = Array.isArray(api.exports) && api.exports.length > 0
                                    ? `<div class="text-slate-700"><span class="font-semibold">Exports:</span> ${api.exports.slice(0, 4).map(item => escapeHtml(item)).join(', ')}${api.exports.length > 4 ? 'â€¦' : ''}</div>`
                                    : '';
                                return `
                                    <div class="bg-white/70 border border-indigo-200/60 rounded-lg p-3 space-y-2">
                                        <div class="font-semibold text-indigo-900">${escapeHtml(api.label || 'API helper')}</div>
                                        <div class="text-slate-700">${escapeHtml(api.summary || 'API helper encapsulates integrations.')}</div>
                                        ${api.endpoint ? `<div class="text-slate-700"><span class="font-semibold">Endpoint:</span> ${escapeHtml(api.endpoint)}</div>` : ''}
                                        ${renderMethodList(api.methods)}
                                        ${renderHttpList(api.httpCalls)}
                                        ${renderSqlList(api.sqlQueries)}
                                        ${exportsList}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>`
                    : '';

                const httpCoverage = Array.isArray(plan.httpCalls) && plan.httpCalls.length > 0
                    ? `<div class="space-y-2">
                        <div class="text-xs uppercase tracking-wide text-indigo-500 font-semibold">HTTP Coverage</div>
                        <div class="space-y-2">
                            ${plan.httpCalls.slice(0, 6).map(call => `
                                <div class="bg-white/60 border border-indigo-200/60 rounded-lg p-3">
                                    <div class="font-semibold text-indigo-900">${escapeHtml((call.method || '').toUpperCase())} ${escapeHtml(call.url || '(dynamic URL)')}</div>
                                    ${Array.isArray(call.sources) && call.sources.length > 0 ? `<div class="text-xs text-slate-600">Sources: ${call.sources.map(source => escapeHtml(source)).join(', ')}</div>` : ''}
                                    ${Array.isArray(call.payloads) && call.payloads.length > 0 ? `<div class="text-xs text-slate-600 mt-1">Payload hints: ${call.payloads.map(payload => escapeHtml(payload)).join(', ')}</div>` : ''}
                                </div>
                            `).join('')}
                            ${plan.httpCalls.length > 6 ? `<div class="text-xs text-slate-500">Showing first 6 HTTP interactions. Review helper code for additional calls.</div>` : ''}
                        </div>
                    </div>`
                    : '';

                const sqlCoverage = Array.isArray(plan.sqlQueries) && plan.sqlQueries.length > 0
                    ? `<div class="space-y-2">
                        <div class="text-xs uppercase tracking-wide text-indigo-500 font-semibold">Database Coverage</div>
                        <div class="space-y-2">
                            ${plan.sqlQueries.slice(0, 5).map(query => `
                                <div class="bg-white/60 border border-indigo-200/60 rounded-lg p-3">
                                    <div class="font-semibold text-indigo-900">Query ${escapeHtml(String(query.index))}</div>
                                    <pre class="mt-2 text-xs text-slate-700 whitespace-pre-wrap">${escapeHtml(query.query || '')}</pre>
                                </div>
                            `).join('')}
                            ${plan.sqlQueries.length > 5 ? `<div class="text-xs text-slate-500">Showing first 5 SQL statements. Inspect helpers for full list.</div>` : ''}
                        </div>
                    </div>`
                    : '';

                planSection = `
                    <div class="space-y-4">
                        <div class="border-t border-indigo-200/60 pt-4">
                            <div class="flex flex-wrap justify-between gap-3 items-start">
                                <div>
                                    <div class="text-sm font-semibold text-indigo-900">Comprehensive Test Plan</div>
                                    <div class="text-slate-700">${escapeHtml(plan.summary || 'Consolidated test activities across spec, flows, and APIs.')}</div>
                                </div>
                                ${coverageBadges}
                            </div>
                            ${planActions}
                            ${highlights ? `<div class="mt-3">
                                <div class="text-xs uppercase tracking-wide text-indigo-500 font-semibold">Functional Highlights</div>
                                ${highlights}
                            </div>` : ''}
                        </div>
                        ${specSection}
                        ${flowCards}
                        ${apiCards}
                        ${httpCoverage}
                        ${sqlCoverage}
                    </div>
                `;
            }

            panel.innerHTML = `
                <div class="flex flex-wrap gap-3 items-center">
                    <div class="font-semibold">AI Evaluation Summary</div>
                    ${riskScore !== null ? `<span class="inline-flex items-center px-2.5 py-1 rounded-full bg-indigo-600 text-white text-xs font-semibold">Risk Score: ${riskScore}</span>` : ''}
                </div>
                <div>${summary}</div>
                <div class="grid gap-4 md:grid-cols-2">
                    <div>
                        <div class="text-xs uppercase tracking-wide text-indigo-500 font-semibold mb-1">Missing Assertions</div>
                        ${missingAssertions}
                    </div>
                    <div>
                        <div class="text-xs uppercase tracking-wide text-indigo-500 font-semibold mb-1">Suggested Improvements</div>
                        ${improvements}
                    </div>
                </div>
                ${helperFeedback ? `<div>
                    <div class="text-xs uppercase tracking-wide text-indigo-500 font-semibold mb-1">Helper Feedback</div>
                    ${helperFeedback}
                </div>` : ''}
                ${planSection}
            `;
        }

        async function handleRunAiEvaluation() {
            if (aiEvaluationInFlight) {
                return;
            }
            const { provider, providerId, apiKey, endpoint, serviceUrl } = await getActiveProviderConfig();
            if (!apiKey) {
                setPreviewModalStatus('Add an API key for the selected provider to run an evaluation.', 'warning');
                return;
            }
            if (!serviceUrl) {
                setPreviewModalStatus('Set the evaluation service URL in AI settings.', 'warning');
                return;
            }
            if (!currentParseResults || !Array.isArray(currentParseResults.testCases)) {
                setPreviewModalStatus('No parsed test cases are available to evaluate.', 'warning');
                return;
            }
            if (activePreviewTestCaseIndex === null || activePreviewTestCaseIndex < 0 || activePreviewTestCaseIndex >= currentParseResults.testCases.length) {
                setPreviewModalStatus('Select a test case before running the AI evaluation.', 'warning');
                return;
            }

            const testCase = currentParseResults.testCases[activePreviewTestCaseIndex];
            const payload = buildAiEvaluationPayload(testCase);
            if (!payload) {
                setPreviewModalStatus('Unable to build evaluation payload for this test case.', 'error');
                return;
            }

            const normalizedServiceUrl = serviceUrl.replace(/\/+$/, '');
            const targetUrl = `${normalizedServiceUrl}/api/evaluate`;

            aiEvaluationInFlight = true;
            updateAiEvaluationButtonState();
            setPreviewModalStatus(`Running ${provider.label} evaluationâ€¦`, 'info');
            updateAiPreviewPanel(null);

            try {
                const response = await fetch(targetUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        providerId,
                        credentials: {
                            apiKey,
                            endpoint
                        },
                        testCase: payload
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(errorText || `Request failed with status ${response.status}`);
                }

                const data = await response.json();
                updateAiPreviewPanel(data);
                setPreviewModalStatus(`${provider.label} evaluation complete.`, 'success');
            } catch (error) {
                console.error('AI evaluation error:', error);
                const fallbackMessage = error?.message || 'AI evaluation failed.';
                const isNetworkError = error instanceof TypeError && /Failed to fetch/i.test(fallbackMessage);
                const diagnosticMessage = isNetworkError
                    ? `Unable to reach the evaluation service at ${targetUrl}. Confirm the companion service is running and the URL is correct.`
                    : fallbackMessage;
                updateAiPreviewPanel({ error: diagnosticMessage });
                setPreviewModalStatus(`AI evaluation failed: ${diagnosticMessage}`, 'error');
            } finally {
                aiEvaluationInFlight = false;
                updateAiEvaluationButtonState();
            }
        }

        function getWorkflowStageIndex(stage) {
            const normalized = stage && WORKFLOW_SEQUENCE.includes(stage) ? stage : 'start';
            return WORKFLOW_SEQUENCE.indexOf(normalized);
        }

        function updateWorkflowStage(stage) {
            if (!stage || !WORKFLOW_PROGRESS.hasOwnProperty(stage)) {
                stage = 'start';
            }

            currentWorkflowStage = stage;

            const percent = WORKFLOW_PROGRESS[stage];
            if (workflowProgressBar) {
                workflowProgressBar.style.width = percent + '%';
            }
            if (workflowProgressPercent) {
                workflowProgressPercent.textContent = `${Math.round(percent)}%`;
            }

            const activeIndex = getWorkflowStageIndex(stage);
            workflowStageLabels.forEach(label => {
                const labelStage = label.getAttribute('data-workflow-stage') || '';
                const labelIndex = getWorkflowStageIndex(labelStage);
                const isActive = stage !== 'start' && labelIndex <= activeIndex;
                label.classList.toggle('text-blue-600', isActive);
                label.classList.toggle('font-semibold', isActive);
                label.classList.toggle('text-slate-400', !isActive);
            });
        }

        updateWorkflowStage('start');

        function generateId() {
            if (window.crypto && typeof window.crypto.randomUUID === 'function') {
                return window.crypto.randomUUID();
            }
            return 'folder-' + Date.now() + '-' + Math.random().toString(16).slice(2);
        }

        function inferRoleByPosition(index, identifier = '') {
            const guessed = inferRoleByName(identifier);
            if (guessed) return guessed;
            return ROLE_OPTIONS[index] || 'aux';
        }

        function inferRoleByName(identifier) {
            if (!identifier) return null;
            const value = identifier.toLowerCase();

            const specKeywords = ['spec', 'test', 'cases', 'tests'];
            const flowKeywords = ['flow', 'journey', 'process'];
            const apiKeywords = ['api', 'service', 'client', 'endpoint', 'rest', 'page', 'pages'];

            if (specKeywords.some(keyword => value.includes(keyword))) {
                return 'spec';
            }
            if (apiKeywords.some(keyword => value.includes(keyword))) {
                return 'api';
            }
            if (flowKeywords.some(keyword => value.includes(keyword))) {
                return 'flow';
            }

            return null;
        }

        function escapeHtml(value) {
            if (!value) return '';
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

    function resetSelectedFolders(message = 'Selection cleared. Drop folders or files to begin.') {
            selectedFolders = [];
                selectionSequence = 0;
            if (folderList) folderList.innerHTML = '';
            if (folderSelection) folderSelection.classList.add('hidden');
            if (analyzeFoldersButton) analyzeFoldersButton.disabled = true;
            currentParseResults = null;
            if (results) {
                results.classList.add('hidden');
            }
            if (resultsContent) {
                resultsContent.innerHTML = '';
            }
                if (orderingPanel) {
                    orderingPanel.classList.add('hidden');
                }
                if (orderingList) {
                    orderingList.innerHTML = '';
                }
            renderFlowVisualization();
            hideProgress();
            if (progressContainer) {
                progressContainer.classList.add('hidden');
            }
            if (progressBar) {
                progressBar.style.width = '0%';
            }
            if (progressText) {
                progressText.textContent = '0%';
            }
            updateStatus(message, 'info');
            updateWorkflowStage('start');
            updateAnalyzeButtonState();
        }

        function startOverWorkflow(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            hideConfigModal();
            selectedSaveDirectory = null;
            currentParseResults = null;
            resetSelectedFolders('Workflow reset. Drop folders or files to begin.');
        }

        function updateAnalyzeButtonState() {
            if (!analyzeFoldersButton) return;
            const hasSelection = Array.isArray(selectedFolders) && selectedFolders.length > 0;
            analyzeFoldersButton.disabled = !hasSelection;
        }

        function renderSelectedFolders() {
            if (!folderList || !folderSelection) {
                updateAnalyzeButtonState();
                renderOrderingPanel();
                return;
            }

            if (!Array.isArray(selectedFolders) || selectedFolders.length === 0) {
                folderSelection.classList.add('hidden');
                folderList.innerHTML = '';
                renderOrderingPanel();
                updateAnalyzeButtonState();
                updateWorkflowStage('start');
                return;
            }

            reindexSelectedFolders();
            folderSelection.classList.remove('hidden');
            if (currentWorkflowStage === 'start' || currentWorkflowStage === 'selection') {
                updateWorkflowStage('selection');
            }

            const items = selectedFolders.map((folder, index) => {
                const roleOptions = ROLE_OPTIONS.map(role => `
                    <option value="${role}" ${folder.role === role ? 'selected' : ''}>${ROLE_DISPLAY[role]}</option>
                `).join('');

                const fileCount = folder.fileCount ?? (folder.files ? folder.files.length : 0);
                const summary = fileCount === 1 ? '1 file' : `${fileCount} files`;
                const label = folder.displayName || folder.fullPath || (folder.files && folder.files[0] && folder.files[0].name) || `Selection ${index + 1}`;

                return `
                    <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 border border-slate-200 rounded-lg p-4 bg-white" data-folder-id="${folder.id}">
                        <div>
                            <div class="text-sm font-semibold text-slate-800">${escapeHtml(label)}</div>
                            <div class="text-xs text-slate-500">${escapeHtml(summary)}</div>
                        </div>
                        <div class="flex items-center gap-3">
                            <label class="text-xs uppercase tracking-wide text-slate-500">Role</label>
                            <select class="border border-slate-200 rounded px-3 py-2 text-sm" data-role-select data-folder-id="${folder.id}">
                                ${roleOptions}
                            </select>
                            <button class="text-xs text-rose-600 hover:text-rose-700" data-action="remove-folder" data-folder-id="${folder.id}">Remove</button>
                        </div>
                    </div>
                `;
            }).join('');

            folderList.innerHTML = items;
            renderOrderingPanel();
            updateAnalyzeButtonState();
        }

        function normalizeSelectionKey(entry) {
            if (!entry) return 'unknown';
            const type = entry.type || 'unknown';
            const identifier = (entry.fullPath || entry.displayName || '').toLowerCase();
            return `${type}:${identifier}`;
        }

        function mergeSelectionEntries(existingEntries, newEntries) {
            const merged = (existingEntries || []).map(entry => ({
                ...entry,
                files: entry.files || [],
                fileCount: entry.fileCount ?? (entry.files ? entry.files.length : 0)
            }));

            const keyMap = new Map();
            merged.forEach(entry => {
                keyMap.set(normalizeSelectionKey(entry), entry);
            });

            for (const addition of newEntries || []) {
                if (!addition) continue;
                const key = normalizeSelectionKey(addition);
                if (keyMap.has(key)) {
                    const target = keyMap.get(key);
                    target.files = addition.files || target.files || [];
                    target.fileCount = addition.fileCount ?? (addition.files ? addition.files.length : target.fileCount ?? (target.files ? target.files.length : 0));
                    if (!target.displayName && addition.displayName) {
                        target.displayName = addition.displayName;
                    }
                    if (!target.fullPath && addition.fullPath) {
                        target.fullPath = addition.fullPath;
                    }
                    if (!target.role && addition.role) {
                        target.role = addition.role;
                    }
                    if (typeof target.initialOrder !== 'number') {
                        target.initialOrder = typeof addition.initialOrder === 'number' ? addition.initialOrder : target.order ?? selectionSequence++;
                    }
                } else {
                    const clone = {
                        ...addition,
                        files: addition.files || [],
                        fileCount: addition.fileCount ?? (addition.files ? addition.files.length : 0),
                        initialOrder: typeof addition.initialOrder === 'number' ? addition.initialOrder : selectionSequence++
                    };
                    merged.push(clone);
                    keyMap.set(key, clone);
                }
            }

            return merged.map((entry, index) => ({
                ...entry,
                order: index,
                role: entry.role || inferRoleByPosition(index, entry.displayName || entry.fullPath || ''),
                fileCount: entry.fileCount ?? (entry.files ? entry.files.length : 0),
                initialOrder: typeof entry.initialOrder === 'number' ? entry.initialOrder : index
            }));
        }

        function renderOrderingPanel() {
            if (!orderingPanel || !orderingList) return;

            if (!Array.isArray(selectedFolders) || selectedFolders.length <= 1) {
                orderingPanel.classList.add('hidden');
                orderingList.innerHTML = '';
                renderFlowVisualization();
                return;
            }

            orderingPanel.classList.remove('hidden');

            const listMarkup = selectedFolders.map((folder, index) => {
                const label = folder.displayName || folder.fullPath || `Selection ${index + 1}`;
                const roleLabel = ROLE_DISPLAY[folder.role] || 'Unassigned';
                const disableUp = index === 0 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-slate-200';
                const disableDown = index === selectedFolders.length - 1 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-slate-200';
                const upDisabledAttr = index === 0 ? 'disabled' : '';
                const downDisabledAttr = index === selectedFolders.length - 1 ? 'disabled' : '';

                return `
                    <div class="flex items-center justify-between bg-slate-50 border border-slate-200 rounded-lg px-3 py-2" data-folder-id="${folder.id}">
                        <div>
                            <div class="text-sm font-medium text-slate-800">${index + 1}. ${escapeHtml(label)}</div>
                            <div class="text-xs text-slate-500">${escapeHtml(roleLabel)}</div>
                        </div>
                        <div class="flex items-center gap-2">
                            <button class="text-xs px-2 py-1 rounded border border-slate-200 ${disableUp}" data-action="move-up" data-folder-id="${folder.id}" ${upDisabledAttr}>â†‘</button>
                            <button class="text-xs px-2 py-1 rounded border border-slate-200 ${disableDown}" data-action="move-down" data-folder-id="${folder.id}" ${downDisabledAttr}>â†“</button>
                        </div>
                    </div>
                `;
            }).join('');

            orderingList.innerHTML = listMarkup;
            renderFlowVisualization();
        }

        function renderFlowVisualization() {
            if (!flowVisualization || !flowVisualizationCanvas) {
                return;
            }

            if (!Array.isArray(selectedFolders) || selectedFolders.length === 0) {
                flowVisualization.classList.add('hidden');
                flowVisualizationCanvas.innerHTML = '';
                flowVisualizationCanvas.style.height = '240px';
                return;
            }

            flowVisualization.classList.remove('hidden');
            const graph = buildFlowVisualizationGraph(selectedFolders);
            flowVisualizationCanvas.innerHTML = graph.svg;
            flowVisualizationCanvas.style.height = `${graph.height}px`;
        }

        function buildFlowVisualizationGraph(folders) {
            const ordered = [...(folders || [])].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
            const columns = {
                spec: [],
                flow: [],
                api: [],
                aux: []
            };

            for (const folder of ordered) {
                const role = ROLE_OPTIONS.includes(folder.role) ? folder.role : 'aux';
                columns[role].push(folder);
            }

            let activeColumns = ['spec', 'flow', 'api', 'aux'].filter(role => columns[role].length > 0);
            if (activeColumns.length === 0) {
                activeColumns = ['spec'];
            }

            const nodeWidth = 200;
            const nodeHeight = 70;
            const columnSpacing = 220;
            const paddingX = 120;
            const paddingY = 90;
            const columnCounts = activeColumns.map(role => columns[role].length || 1);
            const maxRows = columnCounts.length > 0 ? Math.max(...columnCounts) : 1;
            const height = paddingY * 2 + Math.max(maxRows - 1, 0) * 130 + nodeHeight;
            const width = paddingX * 2 + (activeColumns.length - 1) * columnSpacing + nodeWidth;

            const nodes = [];
            const nodesById = new Map();
            const sequenceNumbers = new Map();

            ordered.forEach((folder, index) => {
                sequenceNumbers.set(folder.id, index + 1);
            });

            activeColumns.forEach((role, colIndex) => {
                const colItems = columns[role];
                const count = colItems.length;
                if (count === 0) {
                    return;
                }

                const availableHeight = height - paddingY * 2 - nodeHeight;
                const spacing = count > 1 ? availableHeight / (count - 1) : 0;

                colItems.forEach((folder, itemIndex) => {
                    let y = height / 2;
                    if (count > 1) {
                        y = paddingY + nodeHeight / 2 + itemIndex * spacing;
                    }

                    const x = paddingX + nodeWidth / 2 + colIndex * columnSpacing;
                    const node = {
                        id: folder.id,
                        role,
                        x,
                        y,
                        width: nodeWidth,
                        height: nodeHeight,
                        displayName: folder.displayName || folder.fullPath || `Selection ${sequenceNumbers.get(folder.id) || ''}`,
                        sequence: sequenceNumbers.get(folder.id) || null
                    };
                    nodes.push(node);
                    nodesById.set(folder.id, node);
                });
            });

            const connectors = [];
            for (let i = 0; i < ordered.length - 1; i++) {
                const fromNode = nodesById.get(ordered[i].id);
                const toNode = nodesById.get(ordered[i + 1].id);
                if (!fromNode || !toNode) continue;
                connectors.push({ from: fromNode, to: toNode });
            }

            const roleColors = {
                spec: { stroke: '#fb7185', badge: '#fb7185', badgeText: '#ffffff' },
                flow: { stroke: '#8b5cf6', badge: '#8b5cf6', badgeText: '#ffffff' },
                api: { stroke: '#38bdf8', badge: '#38bdf8', badgeText: '#0f172a' },
                aux: { stroke: '#a855f7', badge: '#a855f7', badgeText: '#ffffff' }
            };

            const svgParts = [];
            svgParts.push(`<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">`);
            svgParts.push(`
                <defs>
                    <marker id="flow-arrow" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto" markerUnits="strokeWidth">
                        <path d="M 0 0 L 12 6 L 0 12 z" fill="rgba(255,255,255,0.92)"></path>
                    </marker>
                    <filter id="flow-node-shadow" x="-10%" y="-10%" width="120%" height="120%">
                        <feDropShadow dx="0" dy="4" stdDeviation="6" flood-color="rgba(15,23,42,0.18)" />
                    </filter>
                </defs>
            `);

            connectors.forEach(({ from, to }) => {
                if (!from || !to) return;
                let path;
                if (Math.abs(from.x - to.x) < 1) {
                    const startX = from.x;
                    const startY = from.y + from.height / 2;
                    const endX = to.x;
                    const endY = to.y - to.height / 2;
                    path = `M ${startX} ${startY} L ${endX} ${endY}`;
                } else if (to.x > from.x) {
                    const startX = from.x + from.width / 2;
                    const startY = from.y;
                    const endX = to.x - to.width / 2;
                    const endY = to.y;
                    const midX = (startX + endX) / 2;
                    path = `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`;
                } else {
                    const startX = from.x - from.width / 2;
                    const startY = from.y;
                    const endX = to.x + to.width / 2;
                    const endY = to.y;
                    const midX = (startX + endX) / 2;
                    path = `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`;
                }

                svgParts.push(`
                    <path d="${path}"
                        fill="none"
                        stroke="rgba(255,255,255,0.85)"
                        stroke-width="3.2"
                        stroke-linecap="round"
                        marker-end="url(#flow-arrow)"
                        opacity="0.9"
                    />
                `);
            });

            nodes.forEach(node => {
                const colors = roleColors[node.role] || roleColors.aux;
                const roleLabel = ROLE_DISPLAY[node.role] || ROLE_DISPLAY.aux;
                svgParts.push(`
                    <g transform="translate(${node.x - node.width / 2}, ${node.y - node.height / 2})" filter="url(#flow-node-shadow)">
                        <rect width="${node.width}" height="${node.height}" rx="18" fill="rgba(255,255,255,0.96)" stroke="${colors.stroke}" stroke-width="1.6" />
                        ${node.sequence ? `<circle cx="22" cy="${node.height / 2}" r="15" fill="${colors.badge}" />
                            <text x="22" y="${node.height / 2 + 4}" text-anchor="middle" class="flow-visualization-node-index" fill="${colors.badgeText}">${escapeHtml(node.sequence)}</text>` : ''}
                        <text x="${node.sequence ? 50 : 24}" y="26" class="flow-visualization-node-role">${escapeHtml(roleLabel)}</text>
                        <text x="${node.sequence ? 50 : 24}" y="48" class="flow-visualization-node-title">${escapeHtml(truncateLabel(node.displayName, 28))}</text>
                    </g>
                `);
            });

            svgParts.push('</svg>');
            return {
                svg: svgParts.join(''),
                height: Math.max(height, 240)
            };
        }

        function truncateLabel(value, maxLength = 28) {
            if (!value) return '';
            const normalized = String(value);
            if (normalized.length <= maxLength) {
                return normalized;
            }
            return normalized.slice(0, maxLength - 1) + 'â€¦';
        }

        function reindexSelectedFolders() {
            if (!Array.isArray(selectedFolders)) return;
            let maxInitial = -1;
            selectedFolders.forEach((folder, index) => {
                folder.order = index;
                if (typeof folder.initialOrder !== 'number') {
                    folder.initialOrder = index;
                }
                if (typeof folder.initialOrder === 'number') {
                    maxInitial = Math.max(maxInitial, folder.initialOrder);
                }
            });
            if (maxInitial >= selectionSequence) {
                selectionSequence = maxInitial + 1;
            }
        }

        function handleOrderingClick(event) {
            const button = event.target.closest('button[data-action]');
            if (!button) return;

            const action = button.getAttribute('data-action');
            if (action !== 'move-up' && action !== 'move-down') {
                return;
            }

            event.preventDefault();
            event.stopPropagation();

            const folderId = button.getAttribute('data-folder-id');
            const currentIndex = selectedFolders.findIndex(folder => folder.id === folderId);
            if (currentIndex === -1) {
                return;
            }

            const targetIndex = action === 'move-up' ? currentIndex - 1 : currentIndex + 1;
            if (targetIndex < 0 || targetIndex >= selectedFolders.length) {
                return;
            }

            const [moved] = selectedFolders.splice(currentIndex, 1);
            selectedFolders.splice(targetIndex, 0, moved);

            reindexSelectedFolders();
            renderSelectedFolders();
            updateStatus(`${escapeHtml(moved.displayName || 'Selection')} moved ${action === 'move-up' ? 'up' : 'down'} in workflow order.`, 'info');
        }

        function resetFolderOrder(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }

            if (!Array.isArray(selectedFolders) || selectedFolders.length <= 1) {
                return;
            }

            selectedFolders.sort((a, b) => {
                const aOrder = typeof a.initialOrder === 'number' ? a.initialOrder : a.order || 0;
                const bOrder = typeof b.initialOrder === 'number' ? b.initialOrder : b.order || 0;
                return aOrder - bOrder;
            });

            reindexSelectedFolders();
            renderSelectedFolders();
            updateStatus('Selection order reset to original sequence.', 'info');
        }

        function handleFolderListInteraction(event) {
            const target = event.target;
            if (!target) return;

            if (target.matches('select[data-role-select]')) {
                const folderId = target.getAttribute('data-folder-id');
                const newRole = target.value;
                const matching = selectedFolders.find(folder => folder.id === folderId);
                if (matching) {
                    matching.role = newRole;
                    updateStatus(`Role for ${matching.displayName || 'selection'} set to ${ROLE_DISPLAY[newRole] || newRole}.`, 'info');
                }
                updateAnalyzeButtonState();
                renderFlowVisualization();
                return;
            }

            if (event.type === 'click' && target.matches('[data-action="remove-folder"]')) {
                event.preventDefault();
                const folderId = target.getAttribute('data-folder-id');
                const removed = selectedFolders.find(folder => folder.id === folderId);
                selectedFolders = selectedFolders.filter(folder => folder.id !== folderId);
                selectedFolders.forEach((folder, index) => {
                    folder.order = index;
                });
                renderSelectedFolders();
                const removedLabel = removed ? (removed.displayName || removed.fullPath || 'Selection') : 'Selection';
                updateStatus(`${escapeHtml(removedLabel)} removed from analysis.`, 'info');
            }
        }

        function autoExpandFolderSelection(selection) {
            if (!selection || selection.type !== 'folder' || !Array.isArray(selection.files)) {
                return null;
            }

            const groups = new Map();

            for (const file of selection.files) {
                const rawPath = (file.relativePath || file.webkitRelativePath || file.name || '').replace(/\\/g, '/');
                const trimmedPath = removeLeadingFolderSegment(rawPath, selection.displayName);
                const normalizedPath = normalizePath(trimmedPath);
                const segments = normalizedPath.split('/').filter(Boolean);

                if (shouldIgnoreHelperPath(normalizedPath)) {
                    continue;
                }

                let groupKey = '__root__';
                let displayLabel = `${selection.displayName}/Root Files`;
                let roleHint = inferRoleByName(selection.displayName);
                if (segments.length > 0) {
                    groupKey = segments[0];
                    displayLabel = `${selection.displayName}/${groupKey}`;
                    roleHint = inferRoleByName(groupKey) || roleHint;
                }

                if (!groups.has(groupKey)) {
                    const ordinal = groups.size;
                    const fallbackName = groupKey === '__root__' ? selection.displayName : groupKey;
                    groups.set(groupKey, {
                        id: generateId(),
                        type: 'folder',
                        displayName: displayLabel,
                        fullPath: displayLabel,
                        role: roleHint || inferRoleByName(file.name) || inferRoleByPosition(ordinal, fallbackName),
                        files: [],
                        fileCount: 0
                    });
                }

                const group = groups.get(groupKey);
                group.files.push(file);
                group.fileCount = group.files.length;
            }

            const expanded = Array.from(groups.values());

            if (expanded.length === 0) {
                return null;
            }

            if (expanded.length === 1 && expanded[0].files.length === selection.files.length) {
                return null;
            }

            return expanded;
        }

        async function analyzeSelectedFolders(event) {
            try {
                if (event && typeof event.preventDefault === 'function') {
                    event.preventDefault();
                }

                if (!selectedFolders || selectedFolders.length === 0) {
                    updateStatus('Select at least one folder or file before analyzing.', 'warning');
                    updateWorkflowStage('start');
                    return;
                }

                updateStatus('Analyzing selected folders and files...', 'info');
                updateWorkflowStage('analysis');
                showProgress();
                updateProgress(5);

                const folderSummaries = [];
                const fileRecords = [];
                const specFilesForParsing = [];
                const unresolvedReferences = [];

                let processedFiles = 0;
                let skippedFiles = 0;

                for (const folder of selectedFolders) {
                    const folderSummary = {
                        folderId: folder.id,
                        displayName: folder.displayName,
                        inferredRole: folder.role,
                        fileSummaries: [],
                        skippedFiles: []
                    };

                    for (const file of folder.files) {
                        const relativePath = getRelativePathForFile(folder, file);
                        const pathWithinFolder = removeLeadingFolderSegment(relativePath, folder.displayName);
                        const extension = getExtension(file.name);
                        const sizeInBytes = file.size;

                        if (shouldIgnoreHelperPath(pathWithinFolder)) {
                            folderSummary.skippedFiles.push({
                                relativePath,
                                reason: 'ignored-helper-utils'
                            });
                            skippedFiles++;
                            continue;
                        }

                        if (!ANALYSIS_SUPPORTED_EXTENSIONS.includes(extension)) {
                            folderSummary.skippedFiles.push({
                                relativePath,
                                reason: 'unsupported-extension'
                            });
                            skippedFiles++;
                            continue;
                        }

                        if (sizeInBytes > ANALYSIS_MAX_FILE_SIZE) {
                            folderSummary.skippedFiles.push({
                                relativePath,
                                reason: 'too-large',
                                sizeInBytes
                            });
                            skippedFiles++;
                            continue;
                        }

                        let content;
                        try {
                            content = await readFileAsync(file);
                        } catch (readError) {
                            folderSummary.skippedFiles.push({
                                relativePath,
                                reason: 'read-error',
                                error: readError.message
                            });
                            skippedFiles++;
                            continue;
                        }

                        const detectedType = detectFileType({
                            folderRole: folder.role,
                            fileName: file.name,
                            content
                        });

                        const imports = extractImports(content);
                        const exports = extractExports(content);
                        const httpCalls = findHttpCalls(content);
                        const metadata = buildMetadataForFile(detectedType, content);

                        const normalizedPath = normalizePath(pathWithinFolder);

                        const fileSummary = {
                            relativePath,
                            pathWithinFolder: normalizedPath,
                            sizeInBytes,
                            detectedType,
                            imports,
                            exports,
                            httpCalls,
                            metadata
                        };

                        folderSummary.fileSummaries.push(fileSummary);
                        processedFiles++;

                        const record = {
                            folderId: folder.id,
                            folderRole: folder.role,
                            displayName: folder.displayName,
                            detectedType,
                            relativePath,
                            pathWithinFolder: normalizedPath,
                            sizeInBytes,
                            imports,
                            exports,
                            httpCalls,
                            metadata,
                            extension
                        };
                        record.keys = buildRecordKeys(record);
                        fileRecords.push(record);

                        if (detectedType === 'spec') {
                            specFilesForParsing.push({
                                filePath: relativePath,
                                content,
                                size: sizeInBytes,
                                relativePath
                            });
                        }

                    }

                    folderSummaries.push(folderSummary);

                    const progressEstimate = Math.min(70, 10 + Math.round((processedFiles / Math.max(1, processedFiles + skippedFiles)) * 50));
                    updateProgress(progressEstimate);
                }

                const relationshipResult = buildRelationships(fileRecords);
                const recordLookup = createRecordLookup(fileRecords);
                const relationships = relationshipResult.relationships;
                unresolvedReferences.push(...relationshipResult.unresolved);

                updateProgress(80);

                // Two-pass: we've now built recordLookup and relationships. Parse spec files in a second pass
                // while providing recordLookup so parseTestSteps can enrich primary steps with helper metadata.
                const parseResults = await parseTestFiles(specFilesForParsing, recordLookup);
                const enrichmentSummary = enrichTestCasesWithRelationships({
                    testCases: parseResults.testCases,
                    relationships,
                    recordLookup
                });

                updateProgress(95);

                const aggregateStats = {
                    totalSelections: selectedFolders.length,
                    totalFilesAnalyzed: processedFiles,
                    skippedFiles,
                    specFiles: fileRecords.filter(r => r.detectedType === 'spec').length,
                    flowFiles: fileRecords.filter(r => r.detectedType === 'flow').length,
                    apiFiles: fileRecords.filter(r => r.detectedType === 'api').length
                };

                currentParseResults = {
                    testCases: parseResults.testCases,
                    stats: parseResults.stats,
                    analysis: {
                        folderSummaries,
                        relationships,
                        unresolvedReferences,
                        aggregateStats,
                        testCaseEnrichmentSummary: enrichmentSummary
                    }
                };

                updateProgress(100);
                hideProgress();

                if (!parseResults.testCases || parseResults.testCases.length === 0) {
                    updateStatus('Analysis complete but no Playwright test cases were detected.', 'warning');
                    updateWorkflowStage('selection');
                } else {
                    updateStatus(`Analysis complete. Found ${parseResults.testCases.length} test case${parseResults.testCases.length === 1 ? '' : 's'}.`, 'success');
                    updateWorkflowStage('ready');
                }

                displayResults(currentParseResults);
                if (parseResults.testCases && parseResults.testCases.length > 0) {
                    showConfigModal();
                }
                console.log('Relationship analysis:', currentParseResults.analysis);
            } catch (error) {
                console.error('Analysis failed:', error);
                hideProgress();
                updateStatus(`Analysis failed: ${error.message}`, 'error');
                updateWorkflowStage(selectedFolders.length > 0 ? 'selection' : 'start');
            }
        }

        function getRelativePathForFile(folder, file) {
            const rawPath = (file.relativePath || file.webkitRelativePath || file.name || '').replace(/\\/g, '/');
            if (folder.type === 'file') {
                return rawPath || folder.displayName;
            }
            if (!rawPath) return folder.displayName;
            if (rawPath.startsWith(folder.displayName + '/')) {
                return rawPath;
            }
            return `${folder.displayName}/${rawPath}`;
        }

        function removeLeadingFolderSegment(path, folderName) {
            if (!path) return '';
            if (!folderName) return path;
            const prefix = `${folderName}/`;
            if (path.startsWith(prefix)) {
                return path.slice(prefix.length);
            }
            return path;
        }

        function getExtension(fileName) {
            const normalized = (fileName || '').toLowerCase();
            const index = normalized.lastIndexOf('.');
            return index >= 0 ? normalized.slice(index) : '';
        }

        function detectFileType({ folderRole, fileName, content }) {
            const lowerName = (fileName || '').toLowerCase();
            if (folderRole && folderRole !== 'aux') {
                return folderRole;
            }

            if (lowerName.includes('spec') || lowerName.includes('test')) {
                return 'spec';
            }
            if (lowerName.includes('flow')) {
                return 'flow';
            }
            if (lowerName.includes('api') || lowerName.includes('service') || lowerName.includes('client') || lowerName.includes('page')) {
                return 'api';
            }

            const trimmedContent = (content || '').slice(0, 2000);
            if (/\btest\s*\(/i.test(trimmedContent) || /\bit\s*\(/i.test(trimmedContent)) {
                return 'spec';
            }
            if (/axios\.|request\./i.test(trimmedContent) || /\bfetch\s*\(/i.test(trimmedContent) || /https?:\/\//i.test(trimmedContent)) {
                return 'api';
            }
            if (/export\s+async?\s*function/i.test(trimmedContent) || /module\.exports\s*=\s*{/.test(trimmedContent)) {
                return 'flow';
            }

            return 'unknown';
        }

        function extractImports(content) {
            const imports = [];
            if (!content) return imports;

            const importRegex = /import\s+([^;]+?)\s+from\s+['"]([^'"]+)['"]/g;
            const bareImportRegex = /import\s+['"]([^'"]+)['"]/g;
            const requireRegex = /require\(\s*['"]([^'"]+)['"]\s*\)/g;

            let match;
            while ((match = importRegex.exec(content)) !== null) {
                imports.push({
                    type: 'import',
                    source: match[2],
                    statement: match[0].trim(),
                    line: getLineNumberForIndex(content, match.index)
                });
            }

            while ((match = bareImportRegex.exec(content)) !== null) {
                imports.push({
                    type: 'import',
                    source: match[1],
                    statement: match[0].trim(),
                    line: getLineNumberForIndex(content, match.index)
                });
            }

            while ((match = requireRegex.exec(content)) !== null) {
                imports.push({
                    type: 'require',
                    source: match[1],
                    statement: match[0].trim(),
                    line: getLineNumberForIndex(content, match.index)
                });
            }

            return dedupeImports(imports);
        }

        function dedupeImports(imports) {
            const seen = new Map();
            for (const imp of imports) {
                if (!seen.has(imp.source)) {
                    seen.set(imp.source, imp);
                }
            }
            return Array.from(seen.values());
        }

        function extractExports(content) {
            const exports = [];
            if (!content) return exports;

            const functionExportRegex = /export\s+(?:async\s+)?function\s+([\w$]+)/g;
            const constExportRegex = /export\s+const\s+([\w$]+)/g;
            const defaultExportRegex = /export\s+default\s+([\w$]+)/g;
            const moduleExportsRegex = /module\.exports\s*=\s*{([^}]+)}/g;

            let match;
            while ((match = functionExportRegex.exec(content)) !== null) {
                exports.push({ name: match[1], type: 'function' });
            }

            while ((match = constExportRegex.exec(content)) !== null) {
                exports.push({ name: match[1], type: 'const' });
            }

            while ((match = defaultExportRegex.exec(content)) !== null) {
                exports.push({ name: match[1], type: 'default' });
            }

            while ((match = moduleExportsRegex.exec(content)) !== null) {
                const exportsBlock = match[1];
                const identifiers = exportsBlock.split(',').map(item => item.trim()).filter(Boolean);
                for (const identifier of identifiers) {
                    const parts = identifier.split(':').map(p => p.trim());
                    const name = parts[0];
                    if (name) {
                        exports.push({ name, type: 'module.exports' });
                    }
                }
            }

            return exports;
        }

        function findHttpCalls(content) {
            if (!content) return [];

            const calls = [];
            const httpRegex = /(?:await\s+)?([\w$\.]+)\.(get|post|put|patch|delete|head|options)\s*\(([^)]*)\)/gi;
            const fetchRegex = /(?:await\s+)?fetch\s*\(([^)]*)\)/gi;

            let match;
            while ((match = httpRegex.exec(content)) !== null) {
                const argumentList = splitCallArguments(match[3] || '');
                const urlArgument = argumentList[0] || '';
                calls.push({
                    method: match[2].toUpperCase(),
                    url: sanitizeStringLiteral(urlArgument),
                    rawSnippet: match[0].trim(),
                    caller: match[1],
                    line: getLineNumberForIndex(content, match.index),
                    arguments: argumentList,
                    body: argumentList[1] || null
                });
            }

            while ((match = fetchRegex.exec(content)) !== null) {
                const argumentList = splitCallArguments(match[1] || '');
                const firstArgument = argumentList[0] || '';
                calls.push({
                    method: 'GET',
                    url: sanitizeStringLiteral(firstArgument),
                    rawSnippet: match[0].trim(),
                    caller: 'fetch',
                    line: getLineNumberForIndex(content, match.index),
                    arguments: argumentList,
                    body: argumentList[1] || null
                });
            }

            return calls;
        }

        function buildMetadataForFile(detectedType, content) {
            if (!content) return {};

            if (detectedType === 'spec') {
                return {
                    testTitles: extractTestTitles(content),
                    stepComments: extractStepComments(content),
                    invokedMethods: extractObjectMethodCalls(content),
                    standaloneCalls: extractStandaloneFunctionCalls(content)
                };
            }

            if (detectedType === 'flow') {
                const classInfo = extractClassMethodSummaries(content);
                return {
                    functionNames: extractFunctionNames(content),
                    objectFunctionNames: extractObjectFunctionNames(content),
                    sqlQueries: extractSqlQueries(content),
                    classMethodSummaries: classInfo.methods,
                    classNames: classInfo.classNames,
                    aliasNames: classInfo.classNames
                };
            }

            if (detectedType === 'api') {
                const classInfo = extractClassMethodSummaries(content);
                return {
                    endpointLiterals: extractEndpointLiterals(content),
                    sqlQueries: extractSqlQueries(content),
                    objectFunctionNames: extractObjectFunctionNames(content),
                    classMethodSummaries: classInfo.methods,
                    classNames: classInfo.classNames,
                    aliasNames: classInfo.classNames
                };
            }

            return {};
        }

        function extractTestTitles(content) {
            const titles = [];
            const regex = /\b(?:test|it)\s*\(\s*['"]([^'"]+)['"]/g;
            let match;
            while ((match = regex.exec(content)) !== null) {
                titles.push(match[1]);
            }
            return titles;
        }

        function extractStepComments(content) {
            const comments = [];
            const regex = /\/\/\s*Step\s*(\d+)[:\-\s]*([^\n]*)/gi;
            let match;
            while ((match = regex.exec(content)) !== null) {
                comments.push({ step: Number(match[1]), description: match[2].trim() });
            }
            return comments;
        }

        function extractObjectMethodCalls(content) {
            const calls = [];
            if (!content) return calls;

            const pattern = /(?<![A-Za-z0-9_$])(await\s+)?([A-Za-z_$][\w$]*)\s*\.\s*([A-Za-z_$][\w$]*)\s*\(/g;
            const ignoreObjects = new Set(['console', 'expect', 'test', 'it', 'describe', 'page']);
            const ignoreMethods = new Set(['only', 'skip', 'each']);

            let match;
            while ((match = pattern.exec(content)) !== null) {
                const objectName = match[2];
                const methodName = match[3];

                if (ignoreObjects.has(objectName) || ignoreMethods.has(methodName)) {
                    continue;
                }

                const line = getLineNumberForIndex(content, match.index);
                calls.push({
                    objectName,
                    methodName,
                    line,
                    snippet: match[0].replace(/\s+$/, '')
                });
            }

            return calls;
        }

        function extractStandaloneFunctionCalls(content) {
            const calls = [];
            if (!content) return calls;

            const pattern = /(?<!\.)\b([A-Za-z_$][\w$]*)\s*\(/g;
            const ignoreNames = new Set(['test', 'it', 'expect', 'describe', 'beforeAll', 'afterAll', 'beforeEach', 'afterEach']);

            let match;
            while ((match = pattern.exec(content)) !== null) {
                const name = match[1];
                if (ignoreNames.has(name)) {
                    continue;
                }
                const line = getLineNumberForIndex(content, match.index);
                calls.push({
                    name,
                    line,
                    snippet: match[0].replace(/\s+$/, '')
                });
            }

            return calls;
        }

        function extractFunctionNames(content) {
            const names = new Set();
            const functionRegex = /function\s+([\w$]+)/g;
            const arrowRegex = /const\s+([\w$]+)\s*=\s*async?\s*\(/g;
            let match;

            while ((match = functionRegex.exec(content)) !== null) {
                names.add(match[1]);
            }

            while ((match = arrowRegex.exec(content)) !== null) {
                names.add(match[1]);
            }

            return Array.from(names);
        }

        function extractObjectFunctionNames(content) {
            if (!content) return [];

            const names = new Set();
            const arrowPropertyRegex = /(\b[A-Za-z_$][\w$]*)\s*:\s*(?:async\s*)?\([^)]*\)\s*=>/g;
            const functionPropertyRegex = /(\b[A-Za-z_$][\w$]*)\s*:\s*(?:async\s*)?function\b/g;
            const shorthandMethodRegex = /(?:^|[,{\s])(?:async\s+)?([A-Za-z_$][\w$]*)\s*\([^)]*\)\s*\{/g;

            let match;

            while ((match = arrowPropertyRegex.exec(content)) !== null) {
                names.add(match[1]);
            }

            while ((match = functionPropertyRegex.exec(content)) !== null) {
                names.add(match[1]);
            }

            while ((match = shorthandMethodRegex.exec(content)) !== null) {
                names.add(match[1]);
            }

            return Array.from(names);
        }

        function extractClassMethodSummaries(content) {
            if (!content) {
                return { classNames: [], methods: [] };
            }

            const classNames = new Set();
            const methods = [];
            const classRegex = /(?:export\s+default\s+|export\s+)?class\s+([A-Za-z0-9_$]+)(?:\s+extends\s+[^{]+)?\s*\{/g;
            let match;

            while ((match = classRegex.exec(content)) !== null) {
                const className = match[1];
                classNames.add(className);

                const braceIndex = content.indexOf('{', match.index);
                if (braceIndex === -1) {
                    continue;
                }

                const classBlock = extractBlockFromIndex(content, braceIndex);
                if (!classBlock) {
                    continue;
                }

                const { methods: classMethods } = extractMethodsFromClass(classBlock.body);
                classMethods.forEach(method => {
                    const summary = summarizeMethodBody(method.body);
                    methods.push({
                        className,
                        methodName: method.name,
                        params: method.params,
                        isAsync: method.isAsync,
                        isStatic: method.isStatic,
                        summary
                    });
                });

                classRegex.lastIndex = classBlock.endIndex + 1;
            }

            return {
                classNames: Array.from(classNames),
                methods
            };
        }

        function extractSqlQueries(content) {
            if (!content) return [];

            const queries = [];
            const sqlRegex = /SELECT[\s\S]*?(?:(?:;)|(\n\s*\n)|[`'"$])/gi;
            let match;
            while ((match = sqlRegex.exec(content)) !== null) {
                const raw = match[0] || '';
                const cleaned = raw.replace(/[`'"$]$/,'').trim();
                if (!cleaned) continue;
                queries.push(cleaned);
            }

            return queries;
        }

        function extractEndpointLiterals(content) {
            const literals = new Set();
            const regex = /https?:[^'"\s)]+/gi;
            let match;
            while ((match = regex.exec(content)) !== null) {
                literals.add(match[0]);
            }
            return Array.from(literals);
        }

        function buildRecordKeys(record) {
            const keys = new Set();
            const normalized = record.pathWithinFolder || '';
            const withoutExt = stripExtension(normalized);
            const filename = withoutExt.split('/').pop();

            if (normalized) keys.add(normalized);
            if (withoutExt) keys.add(withoutExt);
            if (filename) keys.add(filename);

            const tailTwo = withoutExt.split('/').slice(-2).join('/');
            if (tailTwo) keys.add(tailTwo);

            return Array.from(keys).filter(Boolean);
        }

        function buildRelationships(records) {
            const relationships = [];
            const unresolved = [];

            const specRecords = records.filter(record => record.detectedType === 'spec');
            const flowRecords = records.filter(record => record.detectedType === 'flow');
            const apiRecords = records.filter(record => record.detectedType === 'api');

            const flowIndex = createRecordIndex(flowRecords);
            const apiIndex = createRecordIndex(apiRecords);

            for (const specRecord of specRecords) {
                const flowImportMatches = matchImportsToIndex(specRecord, flowIndex, unresolved);
                const apiImportMatches = matchImportsToIndex(specRecord, apiIndex, unresolved);
                const flowMethodMatches = matchSpecMethodCallsToRecords(specRecord, flowRecords);
                const apiMethodMatches = matchSpecMethodCallsToRecords(specRecord, apiRecords);

                const flowSet = new Map();
                const ensureFlowEntry = (record) => {
                    if (!record) return null;
                    const key = record.pathWithinFolder;
                    if (!key) return null;
                    if (!flowSet.has(key)) {
                        flowSet.set(key, {
                            record,
                            evidence: [],
                            sourceSet: new Set(),
                            methodCalls: []
                        });
                    }
                    return flowSet.get(key);
                };

                for (const match of flowImportMatches) {
                    const entry = ensureFlowEntry(match.record);
                    if (!entry) continue;
                    entry.sourceSet.add('spec-import');
                    entry.evidence.push({
                        type: 'import',
                        description: `Spec imports flow ${match.record.pathWithinFolder}`,
                        snippet: match.import.statement,
                        location: {
                            file: specRecord.pathWithinFolder,
                            line: match.import.line
                        }
                    });
                }

                for (const match of flowMethodMatches) {
                    const entry = ensureFlowEntry(match.record);
                    if (!entry) continue;
                    entry.sourceSet.add('spec-method-call');
                    const callLabel = match.call.objectName
                        ? `${match.call.objectName}.${match.call.methodName}()`
                        : `${match.call.methodName}()`;
                    if (match.methodSummary || match.call) {
                        entry.methodCalls.push({
                            methodName: match.methodName,
                            call: match.call,
                            summary: match.methodSummary
                        });
                    }
                    entry.evidence.push({
                        type: 'method-call',
                        description: `Spec calls ${callLabel} which maps to flow ${match.record.pathWithinFolder}`,
                        snippet: match.call.snippet,
                        location: {
                            file: specRecord.pathWithinFolder,
                            line: match.call.line
                        }
                    });
                }

                const apiSet = new Map();
                const ensureApiEntry = (record) => {
                    if (!record) return null;
                    const key = record.pathWithinFolder;
                    if (!key) return null;
                    if (!apiSet.has(key)) {
                        apiSet.set(key, {
                            record,
                            sources: new Set(),
                            evidence: [],
                            matchedBySet: new Set(),
                            call: null,
                            importSource: null,
                            import: null,
                            methodCalls: []
                        });
                    }
                    return apiSet.get(key);
                };

                for (const match of apiImportMatches) {
                    const entry = ensureApiEntry(match.record);
                    if (!entry) continue;
                    entry.sources.add('spec-import');
                    entry.matchedBySet.add('spec-import');
                    entry.import = match.import;
                    entry.importSource = specRecord;
                    entry.evidence.push({
                        type: 'import',
                        description: `Spec imports API/helper ${match.record.pathWithinFolder}`,
                        snippet: match.import.statement,
                        location: {
                            file: specRecord.pathWithinFolder,
                            line: match.import.line
                        }
                    });
                }

                for (const match of apiMethodMatches) {
                    const entry = ensureApiEntry(match.record);
                    if (!entry) continue;
                    entry.sources.add('spec-method-call');
                    entry.matchedBySet.add('spec-method-call');
                    const callLabel = match.call.objectName
                        ? `${match.call.objectName}.${match.call.methodName}()`
                        : `${match.call.methodName}()`;
                    if (match.methodSummary || match.call) {
                        entry.methodCalls.push({
                            methodName: match.methodName,
                            call: match.call,
                            summary: match.methodSummary
                        });
                    }
                    entry.evidence.push({
                        type: 'method-call',
                        description: `Spec calls ${callLabel} which maps to API/helper ${match.record.pathWithinFolder}`,
                        snippet: match.call.snippet,
                        location: {
                            file: specRecord.pathWithinFolder,
                            line: match.call.line
                        }
                    });
                }

                for (const flowEntry of flowSet.values()) {
                    const flowRecord = flowEntry.record;
                    const flowApiMatches = matchImportsToIndex(flowRecord, apiIndex, unresolved);
                    for (const apiMatch of flowApiMatches) {
                        const entry = ensureApiEntry(apiMatch.record);
                        if (!entry) continue;
                        entry.sources.add('flow-import');
                        entry.matchedBySet.add('flow-import');
                        entry.import = apiMatch.import;
                        entry.importSource = flowRecord;
                        entry.evidence.push({
                            type: 'import',
                            description: `Flow ${flowRecord.pathWithinFolder} imports API/helper ${apiMatch.record.pathWithinFolder}`,
                            snippet: apiMatch.import.statement,
                            location: {
                                file: flowRecord.pathWithinFolder,
                                line: apiMatch.import.line
                            }
                        });
                    }

                    for (const call of flowRecord.httpCalls || []) {
                        const key = `${call.method}:${call.url}`;
                        if (!apiSet.has(key)) {
                            apiSet.set(key, {
                                record: null,
                                matchedBy: 'flow-http-call',
                                call,
                                sourceRecord: flowRecord,
                                methodCalls: [],
                                evidence: [{
                                    type: 'http-call',
                                    description: `Flow ${flowRecord.pathWithinFolder} performs ${call.method} ${call.url}`,
                                    snippet: call.rawSnippet,
                                    location: {
                                        file: flowRecord.pathWithinFolder,
                                        line: call.line
                                    }
                                }]
                            });
                        } else {
                            const entry = apiSet.get(key);
                            if (entry && Array.isArray(entry.evidence)) {
                                entry.evidence.push({
                                    type: 'http-call',
                                    description: `Flow ${flowRecord.pathWithinFolder} performs ${call.method} ${call.url}`,
                                    snippet: call.rawSnippet,
                                    location: {
                                        file: flowRecord.pathWithinFolder,
                                        line: call.line
                                    }
                                });
                            }
                        }
                    }
                }

                for (const call of specRecord.httpCalls || []) {
                    const key = `${call.method}:${call.url}`;
                    if (!apiSet.has(key)) {
                        apiSet.set(key, {
                            record: null,
                            matchedBy: 'spec-http-call',
                            call,
                            sourceRecord: specRecord,
                            methodCalls: [],
                            evidence: [{
                                type: 'http-call',
                                description: `Spec ${specRecord.pathWithinFolder} performs ${call.method} ${call.url}`,
                                snippet: call.rawSnippet,
                                location: {
                                    file: specRecord.pathWithinFolder,
                                    line: call.line
                                }
                            }]
                        });
                    } else {
                        const entry = apiSet.get(key);
                        if (entry && Array.isArray(entry.evidence)) {
                            entry.evidence.push({
                                type: 'http-call',
                                description: `Spec ${specRecord.pathWithinFolder} performs ${call.method} ${call.url}`,
                                snippet: call.rawSnippet,
                                location: {
                                    file: specRecord.pathWithinFolder,
                                    line: call.line
                                }
                            });
                        }
                    }
                }

                if (flowSet.size === 0 && apiSet.size === 0) {
                    continue;
                }

                const viaFlows = Array.from(flowSet.values()).map(entry => ({
                    path: entry.record.pathWithinFolder,
                    methodCalls: Array.isArray(entry.methodCalls) ? entry.methodCalls : []
                }));

                const apiInvocations = [];
                const evidence = [];

                for (const entry of flowSet.values()) {
                    for (const item of entry.evidence) {
                        evidence.push(item);
                    }
                }

                for (const entry of apiSet.values()) {
                    if (entry.record) {
                        const matchedBy = entry.matchedBySet && entry.matchedBySet.size > 0
                            ? Array.from(entry.matchedBySet).join(', ')
                            : (entry.matchedBy || 'import');
                        apiInvocations.push({
                            apiFile: entry.record.pathWithinFolder,
                            method: entry.call?.method || 'UNKNOWN',
                            url: entry.call?.url || null,
                            matchedBy,
                            methodCalls: Array.isArray(entry.methodCalls) ? entry.methodCalls : []
                        });
                    } else if (entry.call) {
                        apiInvocations.push({
                            apiFile: null,
                            method: entry.call.method,
                            url: entry.call.url,
                            matchedBy: entry.matchedBy,
                            methodCalls: Array.isArray(entry.methodCalls) ? entry.methodCalls : []
                        });
                    }

                    if (Array.isArray(entry.evidence)) {
                        for (const item of entry.evidence) {
                            evidence.push(item);
                        }
                    }
                }

                const directApiMatch = (apiImportMatches.length > 0) || (apiMethodMatches.length > 0);

                const confidence = computeConfidenceScore({
                    hasFlows: flowSet.size > 0,
                    hasApis: apiInvocations.length > 0,
                    directApis: directApiMatch,
                    httpCalls: (specRecord.httpCalls?.length || 0) + Array.from(flowSet.values()).reduce((sum, entry) => sum + (entry.record.httpCalls?.length || 0), 0)
                });

                relationships.push({
                    fromFile: specRecord.pathWithinFolder,
                    viaFlows,
                    toApis: apiInvocations,
                    confidence,
                    evidence
                });
            }

            return { relationships, unresolved };
        }

        function computeConfidenceScore({ hasFlows, hasApis, directApis, httpCalls }) {
            let score = 0.2;
            if (hasFlows) score += 0.3;
            if (hasApis) score += 0.3;
            if (directApis) score += 0.1;
            if (httpCalls > 0) score += Math.min(0.1, httpCalls * 0.02);
            return Math.min(1, score);
        }

        function createRecordIndex(records) {
            const index = new Map();
            for (const record of records) {
                for (const key of record.keys || []) {
                    const existing = index.get(key) || [];
                    existing.push(record);
                    index.set(key, existing);
                }
            }
            return index;
        }

        function matchImportsToIndex(importerRecord, targetIndex, unresolved) {
            const matches = [];
            const seenRecords = new Set();

            for (const imp of importerRecord.imports || []) {
                const candidateKeys = resolveImportSpecifierKeys(importerRecord.pathWithinFolder, imp.source);
                let foundRecords = [];

                for (const key of candidateKeys) {
                    if (targetIndex.has(key)) {
                        foundRecords = targetIndex.get(key);
                        if (foundRecords.length === 1) {
                            break;
                        }
                    }
                }

                if (foundRecords.length === 1) {
                    const record = foundRecords[0];
                    if (!seenRecords.has(record.pathWithinFolder)) {
                        matches.push({ record, import: imp });
                        seenRecords.add(record.pathWithinFolder);
                    }
                } else if (foundRecords.length > 1) {
                    unresolved.push({
                        sourceFile: importerRecord.pathWithinFolder,
                        reference: imp.source,
                        reason: 'ambiguous'
                    });
                }
            }

            return matches;
        }

        function collectCallableNames(record) {
            const names = new Set();
            if (!record) return names;

            const functionNames = record.metadata?.functionNames;
            if (Array.isArray(functionNames)) {
                functionNames.forEach(name => {
                    if (name) names.add(name.toLowerCase());
                });
            }

            const objectFunctionNames = record.metadata?.objectFunctionNames;
            if (Array.isArray(objectFunctionNames)) {
                objectFunctionNames.forEach(name => {
                    if (name) names.add(String(name).toLowerCase());
                });
            }

            const classMethodSummaries = record.metadata?.classMethodSummaries;
            if (Array.isArray(classMethodSummaries)) {
                classMethodSummaries.forEach(method => {
                    const name = method?.methodName || method?.name;
                    if (name) names.add(String(name).toLowerCase());
                });
            }

            const exportNames = record.exports;
            if (Array.isArray(exportNames)) {
                exportNames.forEach(exp => {
                    const name = exp?.name;
                    if (name) names.add(String(name).toLowerCase());
                });
            }

            return names;
        }

        function collectAliasNames(record) {
            const aliases = new Set();
            if (!record) return aliases;

            const basePath = stripExtension(record.pathWithinFolder || record.relativePath || record.displayName || '');
            if (basePath) {
                const tail = basePath.split('/').pop();
                if (tail) aliases.add(tail.toLowerCase());
            }

            const exportNames = record.exports;
            if (Array.isArray(exportNames)) {
                exportNames.forEach(exp => {
                    const name = exp?.name;
                    if (name) aliases.add(String(name).toLowerCase());
                });
            }

            if (record.metadata?.aliasNames) {
                const aliasNames = Array.isArray(record.metadata.aliasNames)
                    ? record.metadata.aliasNames
                    : [record.metadata.aliasNames];
                aliasNames.filter(Boolean).forEach(name => aliases.add(String(name).toLowerCase()));
            }

            return aliases;
        }

        function findMethodSummaryForCall(record, call) {
            if (!record || !call) return null;
            const summaries = record.metadata?.classMethodSummaries;
            if (!Array.isArray(summaries) || summaries.length === 0) {
                return null;
            }

            const methodLower = String(call.methodName || '').toLowerCase();
            if (!methodLower) return null;

            const objectLower = String(call.objectName || '').toLowerCase();
            const aliasNames = collectAliasNames(record);
            let fallbackMatch = null;

            for (const summary of summaries) {
                const summaryLower = String(summary?.methodName || summary?.name || '').toLowerCase();
                if (!summaryLower || summaryLower !== methodLower) {
                    continue;
                }

                const classLower = String(summary?.className || '').toLowerCase();
                if (objectLower) {
                    if (classLower && (classLower === objectLower || aliasNames.has(classLower))) {
                        return summary;
                    }
                    if (aliasNames.has(objectLower)) {
                        return summary;
                    }
                }

                if (!fallbackMatch) {
                    fallbackMatch = summary;
                }
            }

            return fallbackMatch;
        }

        function extractMethodSummaryDetails(summaryEntry) {
            const result = {
                summaryText: '',
                expectedResultText: ''
            };

            if (!summaryEntry) {
                return result;
            }

            const block = (summaryEntry.summary && typeof summaryEntry.summary === 'object')
                ? summaryEntry.summary
                : summaryEntry;

            if (typeof block === 'string') {
                result.summaryText = block.trim();
                return result;
            }

            if (block && typeof block === 'object') {
                const candidateAction = block.actionText || block.description || block.summary || block.details;
                const candidateExpectation = block.expectedResult || block.expectation || block.result;
                if (candidateAction && typeof candidateAction === 'string') {
                    result.summaryText = candidateAction.trim();
                }
                if (candidateExpectation && typeof candidateExpectation === 'string') {
                    result.expectedResultText = candidateExpectation.trim();
                }
            }

            if (!result.summaryText && summaryEntry && typeof summaryEntry === 'object') {
                if (typeof summaryEntry.summaryText === 'string') {
                    result.summaryText = summaryEntry.summaryText.trim();
                }
                if (typeof summaryEntry.expectedResult === 'string') {
                    result.expectedResultText = summaryEntry.expectedResult.trim();
                }
            }

            return result;
        }

        function matchSpecMethodCallsToRecords(specRecord, targetRecords) {
            const matches = [];
            if (!specRecord || !Array.isArray(targetRecords) || targetRecords.length === 0) {
                return matches;
            }

            const methodCalls = specRecord.metadata?.invokedMethods || [];
            if (methodCalls.length === 0) {
                return matches;
            }

            const seen = new Set();

            for (const call of methodCalls) {
                const methodLower = (call.methodName || '').toLowerCase();
                if (!methodLower) continue;

                const objectLower = (call.objectName || '').toLowerCase();
                const candidateMap = new Map();

                for (const record of targetRecords) {
                    const callableNames = collectCallableNames(record);
                    if (!callableNames.has(methodLower)) continue;

                    const aliasNames = collectAliasNames(record);
                    const aliasMatch = objectLower && aliasNames.has(objectLower);
                    const score = aliasMatch ? 2 : 1;
                    const key = record.pathWithinFolder || record.relativePath || record.displayName || '';

                    if (!candidateMap.has(key) || candidateMap.get(key).score < score) {
                        candidateMap.set(key, {
                            record,
                            call,
                            methodName: call.methodName,
                            score,
                            methodSummary: findMethodSummaryForCall(record, call)
                        });
                    }
                }

                for (const [recordKey, candidate] of candidateMap.entries()) {
                    const dedupeKey = `${recordKey}:${methodLower}`;
                    if (seen.has(dedupeKey)) continue;

                    matches.push({
                        record: candidate.record,
                        call: candidate.call,
                        methodName: candidate.methodName,
                        score: candidate.score,
                        methodSummary: candidate.methodSummary
                    });
                    seen.add(dedupeKey);
                }
            }

            return matches;
        }

        function resolveImportSpecifierKeys(importerPath, specifier) {
            const keys = new Set();
            if (!specifier) return Array.from(keys);

            const sanitized = sanitizeSpecifier(specifier);
            keys.add(sanitized);
            keys.add(stripExtension(sanitized));

            if (specifier.startsWith('.')) {
                const importerDir = dirname(importerPath);
                const resolved = normalizePath(joinPaths(importerDir, specifier));
                keys.add(resolved);
                keys.add(stripExtension(resolved));
                const tail = stripExtension(resolved).split('/').pop();
                if (tail) keys.add(tail);
            }

            const tail = stripExtension(sanitized).split('/').pop();
            if (tail) keys.add(tail);

            return Array.from(keys).filter(Boolean);
        }

        function sanitizeSpecifier(specifier) {
            if (!specifier) return '';
            return specifier
                .replace(/^@\//, '')
                .replace(/^~\//, '')
                .replace(/^src\//, '')
                .replace(/^\.\//, '')
                .replace(/\.\.\//g, '')
                .replace(/\\/g, '/');
        }

        function stripExtension(path) {
            if (!path) return '';
            const index = path.lastIndexOf('.');
            if (index === -1) return path;
            return path.slice(0, index);
        }

        function joinPaths(...segments) {
            return segments.filter(Boolean).join('/');
        }

        function dirname(path) {
            if (!path) return '';
            const normalized = normalizePath(path);
            const index = normalized.lastIndexOf('/');
            if (index === -1) return '';
            return normalized.slice(0, index);
        }

        function normalizePath(path) {
            if (!path) return '';
            const parts = path.replace(/\\/g, '/').split('/');
            const stack = [];
            for (const part of parts) {
                if (!part || part === '.') continue;
                if (part === '..') {
                    stack.pop();
                } else {
                    stack.push(part);
                }
            }
            return stack.join('/');
        }

        function isHelperOrUtilsSegment(segment) {
            if (!segment) return false;
            const normalized = segment
                .replace(/[^a-z0-9]/gi, '')
                .toLowerCase();
            if (!normalized || normalized === '__root__') return false;
            return normalized.includes('helper') || normalized.includes('util');
        }

        function shouldIgnoreHelperPath(path) {
            if (!path) return false;
            const normalized = normalizePath(path);
            if (!normalized) return false;
            const segments = normalized.split('/');
            return segments.some(isHelperOrUtilsSegment);
        }

        function getLineNumberForIndex(content, index) {
            if (index <= 0) return 1;
            const substring = content.slice(0, index);
            return substring.split(/\n/).length;
        }

        function sanitizeStringLiteral(literal) {
            if (!literal) return '';
            return literal
                .replace(/^['"`]/, '')
                .replace(/['"`]$/, '');
        }

        function splitCallArguments(argumentString) {
            if (!argumentString) return [];

            const args = [];
            let current = '';
            let depth = 0;
            let inString = null;
            let escapeNext = false;

            for (let i = 0; i < argumentString.length; i++) {
                const char = argumentString[i];

                if (escapeNext) {
                    current += char;
                    escapeNext = false;
                    continue;
                }

                if (char === '\\') {
                    current += char;
                    escapeNext = true;
                    continue;
                }

                if (inString) {
                    current += char;
                    if (char === inString) {
                        inString = null;
                    }
                    continue;
                }

                if (char === '"' || char === '\'' || char === '`') {
                    inString = char;
                    current += char;
                    continue;
                }

                if (char === '(' || char === '[' || char === '{') {
                    depth++;
                    current += char;
                    continue;
                }

                if (char === ')' || char === ']' || char === '}') {
                    depth = Math.max(0, depth - 1);
                    current += char;
                    continue;
                }

                if (char === ',' && depth === 0) {
                    if (current.trim()) {
                        args.push(current.trim());
                    }
                    current = '';
                    continue;
                }

                current += char;
            }

            if (current.trim()) {
                args.push(current.trim());
            }

            return args;
        }

        // Event Listeners
        const browseFolderButton = document.getElementById('browse-folder-button');
        if (browseFolderButton) {
            browseFolderButton.addEventListener('click', (e) => {
                e.stopPropagation();
                createFileInput('folder').click();
            });
        }

        const browseFilesButton = document.getElementById('browse-files-button');
        if (browseFilesButton) {
            browseFilesButton.addEventListener('click', (e) => {
                e.stopPropagation();
                createFileInput('file').click();
            });
        }

        startOverButtons.forEach(button => button.addEventListener('click', startOverWorkflow));

        if (orderingList) {
            orderingList.addEventListener('click', handleOrderingClick);
        }

        if (resetOrderButton) {
            resetOrderButton.addEventListener('click', resetFolderOrder);
        }

        if (folderList) {
            folderList.addEventListener('change', handleFolderListInteraction);
            folderList.addEventListener('click', handleFolderListInteraction);
        }

        if (analyzeFoldersButton) {
            analyzeFoldersButton.addEventListener('click', analyzeSelectedFolders);
        }

        dropZone.addEventListener('click', () => {
            createFileInput('folder').click();
        });

        // Drag and drop handlers
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });

        dropZone.addEventListener('drop', handleDrop, false);

        initializeAiAssistantSettings().catch(error => {
            console.error('Failed to initialize AI assistant settings:', error);
        });

        if (aiProviderSelect) {
            aiProviderSelect.addEventListener('change', () => {
                handleAiProviderChange().catch(error => {
                    console.error('Failed to handle AI provider change:', error);
                });
            });
        }
        if (aiToggleKeyVisibility) {
            aiToggleKeyVisibility.addEventListener('click', handleAiToggleKeyVisibility);
        }
        if (aiSaveSettingsButton) {
            aiSaveSettingsButton.addEventListener('click', () => {
                handleAiSaveSettings().catch(error => {
                    console.error('Failed to save AI settings:', error);
                    showAiSettingsFeedback('Error saving AI settings. Check console for details.', 'error');
                });
            });
        }
        if (aiClearKeyButton) {
            aiClearKeyButton.addEventListener('click', () => {
                handleAiClearKey().catch(error => {
                    console.error('Failed to clear AI key:', error);
                    showAiSettingsFeedback('Error clearing stored key. Check console for details.', 'error');
                });
            });
        }
        if (previewAiPanel) {
            previewAiPanel.addEventListener('click', handlePlanExportClick);
        }

        // Wait for DOM to be ready, then setup event handlers
        document.addEventListener('DOMContentLoaded', function() {
            setupModalEventHandlers();
        });

        // If DOM is already loaded, setup immediately
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupModalEventHandlers);
        } else {
            setupModalEventHandlers();
        }

        function setupModalEventHandlers() {
            console.log('Setting up modal event handlers...');
            
            // Direct event listener for browse button
            const browseSaveButton = document.getElementById('browse-save-location');
            if (browseSaveButton) {
                console.log('Found browse button, attaching event listener');
                browseSaveButton.addEventListener('click', handleBrowseClick);
            } else {
                console.error('Browse button not found!');
            }

            // Also setup event delegation as backup
            document.addEventListener('click', function(event) {
                if (event.target && event.target.id === 'browse-save-location') {
                    console.log('Event delegation caught browse click');
                    handleBrowseClick(event);
                }
            });

            if (!previewModalInitialized) {
                previewModalInitialized = true;

                if (previewModalClose) {
                    previewModalClose.addEventListener('click', () => hidePreviewModal());
                }

                if (previewModalDismiss) {
                    previewModalDismiss.addEventListener('click', () => hidePreviewModal());
                }

                if (previewModal) {
                    previewModal.addEventListener('click', (event) => {
                        if (event.target === previewModal) {
                            hidePreviewModal();
                        }
                    });
                }

                if (previewRunAiButton) {
                    previewRunAiButton.addEventListener('click', () => {
                        handleRunAiEvaluation().catch(error => {
                            console.error('Preview AI evaluation failed to start:', error);
                            setPreviewModalStatus('AI evaluation could not start due to an internal error.', 'error');
                        });
                    });
                }

                document.addEventListener('keydown', handlePreviewModalKeydown);
            }
        }

        async function handleBrowseClick(event) {
            console.log('=== BROWSE BUTTON CLICKED ===');
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }

            // Check if API exists
            if (!window.electronAPI) {
                console.log('âœ— electronAPI is undefined - using fallback');
                updateStatus('Using fallback save method - will use save dialog during export.', 'info');
                document.getElementById('save-path-display').value = 'Will use save dialog (API not available)';
                return;
            }

            // Check if function exists
            if (!window.electronAPI.chooseSaveDirectory) {
                console.log('âœ— chooseSaveDirectory function missing');
                updateStatus('Directory selection not available - will use save dialog.', 'info');
                document.getElementById('save-path-display').value = 'Will use save dialog (function not available)';
                return;
            }

            try {
                console.log('â†’ Calling chooseSaveDirectory...');
                updateStatus('Opening directory selection dialog...', 'info');
                
                const result = await window.electronAPI.chooseSaveDirectory();
                console.log('â†’ Got result:', result);

                if (result && result.success) {
                    selectedSaveDirectory = result.directoryPath;
                    const pathDisplay = document.getElementById('save-path-display');
                    const saveButton = document.getElementById('config-save');
                    
                    if (pathDisplay) pathDisplay.value = selectedSaveDirectory;
                    if (saveButton) saveButton.disabled = false;
                    
                    updateStatus('Save location selected successfully!', 'success');
                    console.log('Selected directory:', selectedSaveDirectory);
                } else {
                    updateStatus('Directory selection was cancelled.', 'info');
                    console.log('Directory selection cancelled by user');
                }
            } catch (error) {
                console.error('Browse location error:', error);
                updateStatus('Error selecting directory: ' + error.message, 'error');
                document.getElementById('save-path-display').value = 'Will use save dialog (error occurred)';
            }
        }

        document.getElementById('config-save').addEventListener('click', saveConfigAndExport);
        document.getElementById('config-cancel').addEventListener('click', () => {
            hideConfigModal();
            selectedSaveDirectory = null; // Reset for next time
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight() {
            dropZone.classList.add('drag-over');
        }

        function unhighlight() {
            dropZone.classList.remove('drag-over');
        }

        async function handleDrop(e) {
            const items = e.dataTransfer.items;
            if (!items || items.length === 0) {
                updateStatus('No items dropped.', 'warning');
                return;
            }

            const newSelection = [];

            try {
                for (const item of items) {
                    if (!item.webkitGetAsEntry) continue;
                    const entry = item.webkitGetAsEntry();
                    if (!entry) continue;

                    if (entry.isDirectory) {
                        const files = [];
                        await collectFilesFromEntry(entry, files, '');
                        if (files.length === 0) continue;
                        newSelection.push({
                            id: generateId(),
                            type: 'folder',
                            displayName: entry.name,
                            fullPath: entry.fullPath || entry.name,
                            role: inferRoleByPosition(newSelection.length, entry.name || entry.fullPath || ''),
                            order: newSelection.length,
                            files,
                            fileCount: files.length
                        });
                    } else if (entry.isFile) {
                        const file = await new Promise((resolve, reject) => {
                            entry.file(f => resolve(f), reject);
                        });
                        if (!file) continue;
                        const fullPath = entry.fullPath || entry.name;
                        if (shouldIgnoreHelperPath(fullPath)) continue;
                        file.relativePath = entry.fullPath || entry.name;
                        newSelection.push({
                            id: generateId(),
                            type: 'file',
                            displayName: file.name,
                            fullPath: entry.fullPath || file.name,
                            role: inferRoleByPosition(newSelection.length, file.name),
                            order: newSelection.length,
                            files: [file],
                            fileCount: 1
                        });
                    }
                }

                if (newSelection.length === 0) {
                    updateStatus('No supported files or folders were dropped.', 'warning');
                    return;
                }

                let finalSelection = newSelection;
                let autoMessage = null;

                if (finalSelection.length === 1 && finalSelection[0].type === 'folder') {
                    const rootName = finalSelection[0].displayName;
                    const expanded = autoExpandFolderSelection(finalSelection[0]);
                    if (expanded && expanded.length > 0) {
                        finalSelection = expanded;
                        autoMessage = `Auto-detected ${finalSelection.length} grouped selection${finalSelection.length === 1 ? '' : 's'} within ${rootName}. Review and adjust if needed.`;
                    }
                }

                if (finalSelection.length < MIN_SELECTIONS) {
                    updateStatus(`Please drop at least ${MIN_SELECTIONS} item${MIN_SELECTIONS === 1 ? '' : 's'}.`, 'warning');
                    return;
                }

                const preparedSelection = finalSelection.map((entry, index) => {
                    const initialOrder = typeof entry.initialOrder === 'number' ? entry.initialOrder : selectionSequence++;
                    return {
                        ...entry,
                        id: entry.id || generateId(),
                        files: entry.files || [],
                        fileCount: entry.fileCount ?? (entry.files ? entry.files.length : 0),
                        order: selectedFolders.length + index,
                        role: entry.role || inferRoleByPosition(selectedFolders.length + index, entry.displayName || entry.fullPath || ''),
                        initialOrder
                    };
                });

                const previousCount = selectedFolders.length;
                selectedFolders = mergeSelectionEntries(selectedFolders, preparedSelection);
                currentParseResults = null;
                if (results) {
                    results.classList.add('hidden');
                    resultsContent.innerHTML = '';
                }
                if (selectedFolders.length > 0) {
                    updateWorkflowStage('selection');
                }
                renderSelectedFolders();
                const addedCount = selectedFolders.length - previousCount;
                let finalMessage = autoMessage;
                if (!finalMessage) {
                    if (addedCount > 0) {
                        finalMessage = `Added ${addedCount} selection${addedCount === 1 ? '' : 's'}. ${selectedFolders.length} total item${selectedFolders.length === 1 ? '' : 's'} ready for analysis.`;
                    } else {
                        finalMessage = `${selectedFolders.length} selection${selectedFolders.length === 1 ? '' : 's'} ready for analysis.`;
                    }
                }
                updateStatus(finalMessage, 'info');
            } catch (error) {
                console.error('Error processing dropped items:', error);
                updateStatus('Error processing dropped items: ' + error.message, 'error');
            }
        }

        async function collectFilesFromEntry(entry, files, path) {
            const currentPath = path + entry.name + '/';

            const dirReader = entry.createReader();
            const entries = await new Promise((resolve, reject) => {
                dirReader.readEntries(resolve, reject);
            });

            const promises = [];
            for (const subEntry of entries) {
                const relativePath = currentPath + subEntry.name;
                if (shouldIgnoreHelperPath(relativePath)) {
                    continue;
                }
                if (subEntry.isFile) {
                    promises.push(new Promise((resolve) => {
                        subEntry.file((file) => {
                            file.relativePath = currentPath + subEntry.name;
                            files.push(file);
                            resolve();
                        });
                    }));
                } else if (subEntry.isDirectory) {
                    promises.push(collectFilesFromEntry(subEntry, files, currentPath));
                }
            }

            return Promise.all(promises);
        }

        async function processDroppedFiles(files) {
            if (files.length === 0) {
                updateStatus('No files found in dropped folder.', 'warning');
                return;
            }

            try {
                updateStatus('Scanning dropped files for test files...', 'info');
                showProgress();

                const supportedFiles = [];

                for (const file of files) {
                    const extension = file.name.split('.').pop()?.toLowerCase();
                    if (!['js', 'ts', 'mjs'].includes(extension)) continue;
                    const helperPath = file.relativePath || file.webkitRelativePath || file.name;
                    if (shouldIgnoreHelperPath(helperPath)) continue;
                    if (file.name.includes('spec') || file.name.includes('test')) {
                        if (file.size > 5 * 1024 * 1024) { // 5MB limit
                            console.warn(`File ${file.name} is too large (${file.size} bytes), skipping`);
                            continue;
                        }

                        try {
                            const content = await readFileAsync(file);
                            supportedFiles.push({
                                filePath: file.name,
                                content,
                                size: file.size,
                                relativePath: file.relativePath || file.name
                            });
                        } catch (error) {
                            console.warn(`Error reading ${file.name}:`, error);
                        }
                    }
                }

                updateProgress(25);

                if (supportedFiles.length === 0) {
                    updateStatus('No Playwright test files found in the dropped folder.', 'warning');
                    hideProgress();
                    return;
                }

                updateStatus(`Found ${supportedFiles.length} test files. Parsing tests...`, 'info');
                updateProgress(50);

                const result = {
                    files: supportedFiles,
                    error: null,
                    stats: {
                        totalFiles: supportedFiles.length,
                        totalSize: supportedFiles.reduce((sum, f) => sum + f.size, 0)
                    }
                };

                const parseResults = await parseTestFiles(result.files);

                updateProgress(75);

                if (parseResults.testCases.length === 0) {
                    updateStatus('No valid test cases could be parsed from the files.', 'warning');
                    hideProgress();
                    return;
                }

                updateStatus(`${parseResults.testCases.length} test cases parsed successfully!`, 'success');
                updateProgress(100);

                currentParseResults = parseResults;
                displayResults(parseResults);
                showConfigModal();

            } catch (error) {
                console.error('Processing error:', error);
                updateStatus(`Processing failed: ${error.message}`, 'error');
                hideProgress();
            }
        }

        async function handleFileSelection(e, mode = 'folder') {
            const files = Array.from(e.target.files || []);

            if (files.length === 0) {
                updateStatus('No files selected.', 'warning');
                return;
            }

            if (!mode && e.target && e.target.dataset && e.target.dataset.mode) {
                mode = e.target.dataset.mode;
            }

            let selections = [];

            if (mode === 'folder') {
                const bucketMap = new Map();

                for (const file of files) {
                    const relativePath = file.webkitRelativePath || file.relativePath || file.name;
                    const normalizedPath = (relativePath || file.name).replace(/\\/g, '/');
                    const [topFolder, ...rest] = normalizedPath.split('/');
                    const bucketName = topFolder && rest.length > 0 ? topFolder : file.name;

                    if (shouldIgnoreHelperPath(normalizedPath)) {
                        continue;
                    }

                    if (!bucketMap.has(bucketName)) {
                        bucketMap.set(bucketName, {
                            id: generateId(),
                            type: rest.length === 0 ? 'file' : 'folder',
                            displayName: bucketName,
                            role: inferRoleByPosition(bucketMap.size, bucketName),
                            order: bucketMap.size,
                            files: [],
                            fileCount: 0
                        });
                    }

                    const bucket = bucketMap.get(bucketName);
                    bucket.files.push(file);
                    bucket.fileCount = bucket.files.length;
                }

                selections = Array.from(bucketMap.values()).filter(bucket => bucket.files.length > 0);
            } else {
                selections = files.map((file, index) => {
                    file.relativePath = file.relativePath || file.name;
                    if (shouldIgnoreHelperPath(file.relativePath)) {
                        return null;
                    }
                    return {
                        id: generateId(),
                        type: 'file',
                        displayName: file.name,
                        role: inferRoleByPosition(index, file.name),
                        order: index,
                        files: [file],
                        fileCount: 1
                    };
                }).filter(Boolean);
            }

            if (selections.length === 0) {
                updateStatus('No selectable items were found.', 'warning');
                return;
            }

            let finalSelection = selections;
            let autoMessage = null;

            if (finalSelection.length === 1 && finalSelection[0].type === 'folder') {
                const rootName = finalSelection[0].displayName;
                const expanded = autoExpandFolderSelection(finalSelection[0]);
                if (expanded && expanded.length > 0) {
                    finalSelection = expanded;
                    autoMessage = `Auto-detected ${finalSelection.length} grouped selection${finalSelection.length === 1 ? '' : 's'} within ${rootName}. Review and adjust if needed.`;
                }
            }

            if (finalSelection.length < MIN_SELECTIONS) {
                updateStatus(`Please select at least ${MIN_SELECTIONS} item${MIN_SELECTIONS === 1 ? '' : 's'}.`, 'warning');
                return;
            }

            const preparedSelection = finalSelection.map((entry, index) => {
                const initialOrder = typeof entry.initialOrder === 'number' ? entry.initialOrder : selectionSequence++;
                return {
                    ...entry,
                    id: entry.id || generateId(),
                    files: entry.files || [],
                    fileCount: entry.fileCount ?? (entry.files ? entry.files.length : 0),
                    order: selectedFolders.length + index,
                    role: entry.role || inferRoleByPosition(selectedFolders.length + index, entry.displayName || entry.fullPath || ''),
                    initialOrder
                };
            });

            const previousCount = selectedFolders.length;
            selectedFolders = mergeSelectionEntries(selectedFolders, preparedSelection);

            currentParseResults = null;
            if (results) {
                results.classList.add('hidden');
                resultsContent.innerHTML = '';
            }

            if (selectedFolders.length > 0) {
                updateWorkflowStage('selection');
            }

            renderSelectedFolders();
            const addedCount = selectedFolders.length - previousCount;
            let finalMessage = autoMessage;
            if (!finalMessage) {
                if (addedCount > 0) {
                    finalMessage = `Added ${addedCount} selection${addedCount === 1 ? '' : 's'} from browse. ${selectedFolders.length} total item${selectedFolders.length === 1 ? '' : 's'} ready for analysis.`;
                } else {
                    finalMessage = `${selectedFolders.length} item${selectedFolders.length === 1 ? '' : 's'} ready for analysis.`;
                }
            }
            updateStatus(finalMessage, 'info');
        }

        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));
                reader.readAsText(file);
            });
        }

        function findMatchingBrace(source, startIndex) {
            if (!source || startIndex < 0 || startIndex >= source.length) return -1;
            let depth = 0;
            let inString = null;
            let escapeNext = false;
            let inLineComment = false;
            let inBlockComment = false;

            for (let i = startIndex; i < source.length; i++) {
                const char = source[i];
                const nextChar = source[i + 1];

                if (inLineComment) {
                    if (char === '\n') {
                        inLineComment = false;
                    }
                    continue;
                }

                if (inBlockComment) {
                    if (char === '*' && nextChar === '/') {
                        inBlockComment = false;
                        i++;
                    }
                    continue;
                }

                if (inString) {
                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }
                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }
                    if (char === inString) {
                        inString = null;
                    }
                    continue;
                }

                if (char === '/' && nextChar === '/') {
                    inLineComment = true;
                    i++;
                    continue;
                }

                if (char === '/' && nextChar === '*') {
                    inBlockComment = true;
                    i++;
                    continue;
                }

                if (char === '"' || char === '\'' || char === '`') {
                    inString = char;
                    continue;
                }

                if (char === '{') {
                    depth++;
                    continue;
                }

                if (char === '}') {
                    depth--;
                    if (depth === 0) {
                        return i;
                    }
                    continue;
                }
            }

            return -1;
        }

        function extractBlockFromIndex(source, braceIndex) {
            const endIndex = findMatchingBrace(source, braceIndex);
            if (endIndex === -1) {
                return null;
            }
            return {
                body: source.slice(braceIndex + 1, endIndex),
                endIndex
            };
        }

        function extractMethodsFromClass(classBody) {
            const result = {
                constructor: null,
                methods: []
            };

            if (!classBody) {
                return result;
            }

            const methodRegex = /(?:(?:async|static)\s+)*([A-Za-z0-9_$]+)\s*\(([^)]*)\)\s*\{/g;
            let match;

            while ((match = methodRegex.exec(classBody)) !== null) {
                const methodName = match[1];
                const params = (match[2] || '').trim();
                const braceIndex = methodRegex.lastIndex - 1;
                const block = extractBlockFromIndex(classBody, braceIndex);
                if (!block) {
                    continue;
                }

                const methodDetails = {
                    name: methodName,
                    params,
                    body: block.body.trim(),
                    isAsync: /\basync\b/.test(match[0]),
                    isStatic: /\bstatic\b/.test(match[0])
                };

                if (methodName === 'constructor') {
                    result.constructor = methodDetails;
                } else {
                    result.methods.push(methodDetails);
                }

                methodRegex.lastIndex = block.endIndex + 1;
            }

            return result;
        }

        function summarizeMethodBody(body) {
            const actionText = extractActions(body);
            const expectationParts = extractExpectations(body);
            const fallback = body
                .split('\n')
                .map(line => line.trim())
                .filter(line => line && !line.startsWith('//'))
                .slice(0, 4)
                .join('\n');

            return {
                actionText: actionText || fallback || 'Review method implementation.',
                expectedResult: expectationParts.join('\n') || 'Method completes successfully.'
            };
        }

        function extractClassTestCases(content, filePath) {
            if (!content) return [];

            const classRegex = /(?:export\s+default\s+|export\s+)?class\s+([A-Za-z0-9_$]+)(?:\s+extends\s+[^{]+)?\s*\{/g;
            const testCases = [];
            let match;

            while ((match = classRegex.exec(content)) !== null) {
                const className = match[1];
                const braceIndex = content.indexOf('{', match.index);
                if (braceIndex === -1) {
                    continue;
                }

                const classBlock = extractBlockFromIndex(content, braceIndex);
                if (!classBlock) {
                    continue;
                }

                const { constructor, methods } = extractMethodsFromClass(classBlock.body);
                const steps = [];
                let stepCounter = 1;

                if (constructor) {
                    const summary = summarizeMethodBody(constructor.body);
                    const ctorParams = constructor.params ? `(${constructor.params})` : '()';
                    steps.push({
                        id: stepCounter++,
                        action: `Constructor for ${className}${ctorParams}\n\n${summary.actionText}`,
                        expectedResult: summary.expectedResult
                    });
                }

                for (const method of methods) {
                    const summary = summarizeMethodBody(method.body);
                    const paramsDisplay = method.params ? `(${method.params})` : '()';
                    const modifiers = `${method.isStatic ? 'static ' : ''}${method.isAsync ? 'async ' : ''}`.trim();
                    const modifierLabel = modifiers ? `${modifiers} ` : '';
                    steps.push({
                        id: stepCounter++,
                        action: `${modifierLabel}method ${className}.${method.name}${paramsDisplay}\n\n${summary.actionText}`,
                        expectedResult: summary.expectedResult
                    });
                }

                if (steps.length > 0) {
                    testCases.push({
                        title: `${className} class workflow`,
                        filePath,
                        steps
                    });
                }

                classRegex.lastIndex = classBlock.endIndex + 1;
            }

            return testCases;
        }

        async function parseTestFiles(files, recordLookup) {
            const results = {
                testCases: [],
                stats: {
                    totalFiles: files.length,
                    totalTests: 0,
                    filesWithTests: 0,
                    parsingErrors: 0
                }
            };

            for (const file of files) {
                try {
                    const parsedTests = parseFileContent(file.content, file.relativePath, recordLookup);
                    const classBasedTests = extractClassTestCases(file.content, file.relativePath);

                    if (parsedTests.length > 0) {
                        results.testCases.push(...parsedTests);
                    }

                    if (classBasedTests.length > 0) {
                        results.testCases.push(...classBasedTests);
                    }

                    if (parsedTests.length > 0 || classBasedTests.length > 0) {
                        results.stats.filesWithTests++;
                    }

                    results.stats.totalTests += parsedTests.length + classBasedTests.length;
                } catch (error) {
                    console.warn(`Error parsing ${file.relativePath}:`, error);
                    results.stats.parsingErrors++;
                }
            }

            return results;
        }

        function createRecordLookup(records) {
            const lookup = new Map();
            for (const record of records || []) {
                const key = normalizePath(record?.pathWithinFolder || record?.relativePath || record?.displayName || '');
                if (!key || lookup.has(key)) continue;
                lookup.set(key, record);
            }
            return lookup;
        }

        function enrichTestCasesWithRelationships({ testCases, relationships, recordLookup }) {
            if (!Array.isArray(testCases) || testCases.length === 0 || !Array.isArray(relationships) || relationships.length === 0) {
                return [];
            }

            const groupedBySpec = new Map();
            for (const relationship of relationships) {
                const specKey = normalizePath(relationship?.fromFile || '');
                if (!specKey) continue;
                if (!groupedBySpec.has(specKey)) {
                    groupedBySpec.set(specKey, []);
                }
                groupedBySpec.get(specKey).push(relationship);
            }

            const enrichmentSummary = [];

            for (const testCase of testCases) {
                const specKey = normalizePath(testCase?.filePath || '');
                if (!specKey || !groupedBySpec.has(specKey)) continue;

                const related = groupedBySpec.get(specKey);
                const appendedSteps = [];
                const usedFlows = new Set();
                const usedApis = new Set();
                let nextId = Array.isArray(testCase.steps) && testCase.steps.length > 0
                    ? Math.max(...testCase.steps.map(step => Number(step.id) || 0))
                    : 0;

                const aggregatedContext = {
                    flows: new Map(),
                    apis: new Map(),
                    httpCalls: new Map(),
                    sqlQueries: new Map()
                };

                const ensureContextLabel = (label, fallbackPrefix) => {
                    if (label && typeof label === 'string') {
                        return label;
                    }
                    return `${fallbackPrefix || 'resource'}-${aggregatedContext[fallbackPrefix === 'api' ? 'apis' : 'flows'].size + 1}`;
                };

                const addHttpCallContext = (call, sourceLabel) => {
                    if (!call) return;
                    const method = (call.method || 'REQUEST').toUpperCase();
                    const url = call.url || '(dynamic URL)';
                    const key = `${method}:${url}`;

                    if (!aggregatedContext.httpCalls.has(key)) {
                        aggregatedContext.httpCalls.set(key, {
                            method,
                            url,
                            sources: new Set(),
                            payloads: new Set()
                        });
                    }

                    const entry = aggregatedContext.httpCalls.get(key);
                    if (sourceLabel) {
                        entry.sources.add(sourceLabel);
                    }
                    if (call.body) {
                        entry.payloads.add(truncateMultiline(call.body, 400));
                    }
                };

                const addSqlQueryContext = (query, originLabel) => {
                    if (!query) return;
                    const normalizedQuery = query.trim();
                    if (!normalizedQuery) return;
                    const key = `${originLabel}:${normalizedQuery}`;
                    if (!aggregatedContext.sqlQueries.has(key)) {
                        aggregatedContext.sqlQueries.set(key, {
                            origin: originLabel,
                            query: normalizedQuery
                        });
                    }
                };

                const registerFlowContext = (label, flowRecord, methodCalls = []) => {
                    if (!label) return;
                    const normalizedLabel = ensureContextLabel(normalizePath(label), 'flow');
                    if (!aggregatedContext.flows.has(normalizedLabel)) {
                        aggregatedContext.flows.set(normalizedLabel, {
                            label: normalizedLabel,
                            functionNames: new Set(),
                            httpCalls: new Map(),
                            sqlQueries: new Map(),
                            invokedMethods: new Map()
                        });
                    }

                    const entry = aggregatedContext.flows.get(normalizedLabel);
                    const functionNames = Array.isArray(flowRecord?.metadata?.functionNames)
                        ? flowRecord.metadata.functionNames
                        : [];
                    functionNames.forEach(name => {
                        if (name) {
                            entry.functionNames.add(name);
                        }
                    });

                    const httpCalls = Array.isArray(flowRecord?.httpCalls) ? flowRecord.httpCalls : [];
                    httpCalls.forEach(call => {
                        const method = (call.method || 'REQUEST').toUpperCase();
                        const url = call.url || '(dynamic URL)';
                        const callKey = `${method}:${url}`;
                        if (!entry.httpCalls.has(callKey)) {
                            entry.httpCalls.set(callKey, { method, url });
                        }
                        addHttpCallContext(call, normalizedLabel);
                    });

                    const sqlQueries = Array.isArray(flowRecord?.metadata?.sqlQueries)
                        ? flowRecord.metadata.sqlQueries
                        : [];
                    sqlQueries.forEach(query => {
                        entry.sqlQueries.set(`${normalizedLabel}:${query}`, query);
                        addSqlQueryContext(query, normalizedLabel);
                    });

                    const methodDetails = Array.isArray(methodCalls) ? methodCalls : [];
                    methodDetails.forEach(item => {
                        if (!item) return;
                        const call = item.call || {};
                        const methodName = item.methodName || call.methodName;
                        if (!methodName) return;
                        const key = methodName.toLowerCase();
                        if (!entry.invokedMethods.has(key)) {
                            const summaryInfo = extractMethodSummaryDetails(item.summary || {});
                            entry.invokedMethods.set(key, {
                                methodName,
                                summaryText: summaryInfo.summaryText,
                                expectedResultText: summaryInfo.expectedResultText,
                                className: item.summary?.className || (flowRecord?.metadata?.classNames?.[0] || ''),
                                objectName: call.objectName || '',
                                snippet: call.snippet || '',
                                params: item.summary?.params || '',
                                isAsync: !!item.summary?.isAsync,
                                isStatic: !!item.summary?.isStatic,
                                line: call.line ?? null
                            });
                        }
                    });
                };

                const registerApiContext = (label, apiRecord, endpointHint = '', methodCalls = []) => {
                    if (!label) return;
                    const normalizedLabel = ensureContextLabel(normalizePath(label), 'api');
                    if (!aggregatedContext.apis.has(normalizedLabel)) {
                        aggregatedContext.apis.set(normalizedLabel, {
                            label: normalizedLabel,
                            endpoint: endpointHint || '',
                            exports: new Set(),
                            httpCalls: new Map(),
                            sqlQueries: new Map(),
                            invokedMethods: new Map()
                        });
                    }

                    const entry = aggregatedContext.apis.get(normalizedLabel);
                    if (endpointHint && !entry.endpoint) {
                        entry.endpoint = endpointHint;
                    }

                    const exportNames = Array.isArray(apiRecord?.exports)
                        ? apiRecord.exports.map(exp => exp?.name).filter(Boolean)
                        : [];
                    exportNames.forEach(name => entry.exports.add(name));

                    const httpCalls = Array.isArray(apiRecord?.httpCalls) ? apiRecord.httpCalls : [];
                    httpCalls.forEach(call => {
                        const method = (call.method || 'REQUEST').toUpperCase();
                        const url = call.url || '(dynamic URL)';
                        const callKey = `${method}:${url}`;
                        if (!entry.httpCalls.has(callKey)) {
                            entry.httpCalls.set(callKey, { method, url });
                        }
                        addHttpCallContext(call, normalizedLabel);
                    });

                    const sqlQueries = Array.isArray(apiRecord?.metadata?.sqlQueries)
                        ? apiRecord.metadata.sqlQueries
                        : [];
                    sqlQueries.forEach(query => {
                        entry.sqlQueries.set(`${normalizedLabel}:${query}`, query);
                        addSqlQueryContext(query, normalizedLabel);
                    });

                    const methodDetails = Array.isArray(methodCalls) ? methodCalls : [];
                    methodDetails.forEach(item => {
                        if (!item) return;
                        const call = item.call || {};
                        const methodName = item.methodName || call.methodName;
                        if (!methodName) return;
                        const key = methodName.toLowerCase();
                        if (!entry.invokedMethods.has(key)) {
                            const summaryInfo = extractMethodSummaryDetails(item.summary || {});
                            entry.invokedMethods.set(key, {
                                methodName,
                                summaryText: summaryInfo.summaryText,
                                expectedResultText: summaryInfo.expectedResultText,
                                className: item.summary?.className || (apiRecord?.metadata?.classNames?.[0] || ''),
                                objectName: call.objectName || '',
                                snippet: call.snippet || '',
                                params: item.summary?.params || '',
                                isAsync: !!item.summary?.isAsync,
                                isStatic: !!item.summary?.isStatic,
                                line: call.line ?? null
                            });
                        }
                    });
                };

                for (const relationship of related) {
                    for (const flowEntry of relationship.viaFlows || []) {
                        const flowPath = typeof flowEntry === 'string'
                            ? flowEntry
                            : (flowEntry?.path || '');
                        const methodCalls = (flowEntry && typeof flowEntry === 'object' && Array.isArray(flowEntry.methodCalls))
                            ? flowEntry.methodCalls
                            : [];

                        const normalizedFlowPath = normalizePath(flowPath || '');
                        if (!normalizedFlowPath || usedFlows.has(normalizedFlowPath)) continue;
                        usedFlows.add(normalizedFlowPath);

                        const flowRecord = recordLookup?.get(normalizedFlowPath);
                        registerFlowContext(normalizedFlowPath, flowRecord, methodCalls);
                        const flowSteps = buildFlowStep(flowRecord, normalizedFlowPath, methodCalls) || [];
                        for (const step of flowSteps) {
                            const enrichedStep = Object.assign({}, step);
                            enrichedStep.id = ++nextId;
                            enrichedStep.source = 'relationship-flow';
                            appendedSteps.push(enrichedStep);
                        }
                    }

                    for (const apiEntry of relationship.toApis || []) {
                        const apiKey = apiEntry?.apiFile
                            ? normalizePath(apiEntry.apiFile)
                            : `${apiEntry?.method || 'REQUEST'}:${apiEntry?.url || ''}`;
                        if (!apiKey || usedApis.has(apiKey)) continue;
                        usedApis.add(apiKey);

                        const apiRecord = apiEntry?.apiFile ? recordLookup?.get(normalizePath(apiEntry.apiFile)) : null;
                        const endpointHint = apiEntry?.url
                            || apiRecord?.httpCalls?.[0]?.url
                            || (Array.isArray(apiRecord?.metadata?.endpointLiterals) && apiRecord.metadata.endpointLiterals[0])
                            || '';
                        const methodCalls = Array.isArray(apiEntry?.methodCalls) ? apiEntry.methodCalls : [];
                        registerApiContext(apiEntry?.apiFile || apiKey, apiRecord, endpointHint, methodCalls);
                        const apiSteps = buildApiStep(apiEntry, apiRecord) || [];
                        for (const step of apiSteps) {
                            const enrichedStep = Object.assign({}, step);
                            enrichedStep.id = ++nextId;
                            enrichedStep.source = 'relationship-api';
                            appendedSteps.push(enrichedStep);
                        }

                        if (apiEntry?.call) {
                            addHttpCallContext(apiEntry.call, normalizePath(apiEntry.apiFile || apiKey));
                        }
                    }
                }

                if (appendedSteps.length > 0) {
                    if (!Array.isArray(testCase.steps)) {
                        testCase.steps = [];
                    }
                    testCase.steps.push(...appendedSteps);
                    renumberTestSteps(testCase);

                    enrichmentSummary.push({
                        caseTitle: testCase.title,
                        addedSteps: appendedSteps.length
                    });
                }

                const flowsContext = Array.from(aggregatedContext.flows.values()).map(entry => ({
                    label: entry.label,
                    functionNames: Array.from(entry.functionNames),
                    methods: Array.from(entry.invokedMethods.values()),
                    httpCalls: Array.from(entry.httpCalls.values()),
                    sqlQueries: Array.from(entry.sqlQueries.values())
                }));

                const apisContext = Array.from(aggregatedContext.apis.values()).map(entry => ({
                    label: entry.label,
                    endpoint: entry.endpoint,
                    exports: Array.from(entry.exports),
                    methods: Array.from(entry.invokedMethods.values()),
                    httpCalls: Array.from(entry.httpCalls.values()),
                    sqlQueries: Array.from(entry.sqlQueries.values())
                }));

                const httpContext = Array.from(aggregatedContext.httpCalls.values()).map(entry => ({
                    method: entry.method,
                    url: entry.url,
                    sources: Array.from(entry.sources),
                    payloads: Array.from(entry.payloads)
                }));

                const sqlContext = Array.from(aggregatedContext.sqlQueries.values());

                if (flowsContext.length || apisContext.length || httpContext.length || sqlContext.length) {
                    testCase.supportingContext = {
                        flows: flowsContext,
                        apis: apisContext,
                        httpCalls: httpContext,
                        sqlQueries: sqlContext
                    };
                }
            }

            return enrichmentSummary;
        }

        function buildFlowStep(flowRecord, fallbackPath, methodCalls = []) {
            const steps = [];
            const label = flowRecord?.pathWithinFolder || fallbackPath || 'Flow helper';
            const functionNames = Array.isArray(flowRecord?.metadata?.functionNames)
                ? flowRecord.metadata.functionNames.filter(Boolean)
                : [];
            const httpCalls = Array.isArray(flowRecord?.httpCalls)
                ? flowRecord.httpCalls.filter(call => call && call.method && call.url)
                : [];
            const sqlQueries = Array.isArray(flowRecord?.metadata?.sqlQueries)
                ? flowRecord.metadata.sqlQueries.filter(Boolean)
                : [];

            const normalizedMethodCalls = Array.isArray(methodCalls) ? methodCalls : [];
            const methodDetails = [];
            const seenMethodKeys = new Set();
            const defaultClassName = Array.isArray(flowRecord?.metadata?.classNames) && flowRecord.metadata.classNames.length > 0
                ? flowRecord.metadata.classNames[0]
                : '';

            normalizedMethodCalls.forEach(item => {
                if (!item) return;
                const call = item.call || {};
                const methodName = item.methodName || call.methodName;
                if (!methodName) return;
                const key = `${methodName.toLowerCase()}:${call.line ?? ''}`;
                if (seenMethodKeys.has(key)) {
                    return;
                }
                seenMethodKeys.add(key);

                const summary = item.summary || {};
                const summaryInfo = extractMethodSummaryDetails(summary);
                const snippet = call.snippet ? truncateMultiline(call.snippet, 280) : '';
                methodDetails.push({
                    methodName,
                    className: summary.className || defaultClassName || '',
                    objectName: call.objectName || '',
                    summaryText: summaryInfo.summaryText,
                    expectedResultText: summaryInfo.expectedResultText,
                    params: summary.params || '',
                    isAsync: !!summary.isAsync,
                    isStatic: !!summary.isStatic,
                    snippet,
                    line: call.line ?? null
                });
            });

            methodDetails.forEach((detail, index) => {
                const callLabel = `${detail.objectName ? detail.objectName + '.' : ''}${detail.methodName}()`;
                const actionParts = [];
                const headline = detail.summaryText || `Execute ${callLabel}`;
                actionParts.push(headline);
                actionParts.push(`Method call: ${callLabel} (source: ${label})`);
                if (detail.params) {
                    actionParts.push(`Parameters: ${detail.params}`);
                }
                if (detail.snippet) {
                    actionParts.push(`Code reference:
${detail.snippet}`);
                }

                const methodStep = {
                    action: actionParts.join('\n\n'),
                    expectedResult: detail.expectedResultText || 'Helper method completes successfully and returns the expected state needed by the spec.',
                    context: {
                        resourceType: 'flow-method',
                        resourcePath: label,
                        sequence: index + 1,
                        details: {
                            methodName: detail.methodName,
                            className: detail.className,
                            objectName: detail.objectName,
                            summaryText: detail.summaryText,
                            expectedResultText: detail.expectedResultText,
                            summary: detail.summaryText,
                            expectedResult: detail.expectedResultText,
                            params: detail.params,
                            isAsync: detail.isAsync,
                            isStatic: detail.isStatic,
                            snippet: detail.snippet,
                            line: detail.line
                        }
                    }
                };

                steps.push(methodStep);
            });

            const descriptionParts = [`Execute flow helper "${label}" to orchestrate supporting actions.`];
            if (functionNames.length > 0) {
                descriptionParts.push(`Functions covered: ${functionNames.slice(0, 5).join(', ')}${functionNames.length > 5 ? 'â€¦' : ''}`);
            }
            if (methodDetails.length > 0) {
                const methodPreview = methodDetails.slice(0, 5).map(detail => `${detail.methodName}${detail.summaryText ? ` â€” ${detail.summaryText}` : ''}`).join('; ');
                descriptionParts.push(`Spec-invoked methods: ${methodPreview}${methodDetails.length > 5 ? 'â€¦' : ''}`);
            }
            if (httpCalls.length > 0) {
                const preview = httpCalls.slice(0, 3).map(call => `${(call.method || '').toUpperCase()} ${call.url || '(dynamic URL)'}`).join('; ');
                descriptionParts.push(`HTTP interactions detected: ${preview}${httpCalls.length > 3 ? ` (+${httpCalls.length - 3} more)` : ''}`);
            }

            if (sqlQueries.length > 0) {
                descriptionParts.push('Contains database interactions that will be detailed in later steps.');
            }

            const summaryStep = {
                action: descriptionParts.join('\n\n'),
                expectedResult: 'Flow logic completes successfully and prepares data for downstream API calls.',
                context: {
                    resourceType: 'flow',
                    resourcePath: label
                }
            };
            summaryStep.context.details = {
                flowLabel: label,
                functionNames,
                invokedMethods: methodDetails,
                httpCalls: httpCalls.map(call => ({
                    method: (call.method || '').toUpperCase(),
                    url: call.url || '(dynamic URL)'
                })),
                httpCallCount: httpCalls.length,
                sqlCount: sqlQueries.length,
                sqlSamples: sqlQueries.slice(0, 3)
            };
            steps.push(summaryStep);

            httpCalls.forEach((call, index) => {
                const httpStep = buildHttpCallStep({
                    call,
                    sourceLabel: label,
                    order: index + 1,
                    defaultExpectation: 'HTTP request succeeds with expected status code and schema validation passes.'
                });
                if (httpStep) {
                    httpStep.context = Object.assign({}, httpStep.context || {}, {
                        resourceType: 'flow-http',
                        resourcePath: label
                    });
                    steps.push(httpStep);
                }
            });

            sqlQueries.forEach((query, index) => {
                const sqlStep = {
                    action: `Database query via ${label}\n\n${query}`,
                    expectedResult: 'Query executes successfully and returns the expected dataset for downstream usage.',
                    context: {
                        resourceType: 'flow-sql',
                        resourcePath: label,
                        sequence: index + 1,
                        details: {
                            flowLabel: label,
                            query
                        }
                    }
                };
                steps.push(sqlStep);
            });

            return steps;
        }

        function buildApiStep(apiEntry, apiRecord) {
            if (!apiEntry && !apiRecord) {
                return [];
            }

            const steps = [];
            const helperLabel = apiRecord?.pathWithinFolder || apiEntry?.apiFile || 'API helper';
            const endpoint = apiEntry?.url
                || apiRecord?.httpCalls?.[0]?.url
                || (Array.isArray(apiRecord?.metadata?.endpointLiterals) && apiRecord.metadata.endpointLiterals[0])
                || '';

            const methodCalls = Array.isArray(apiEntry?.methodCalls) ? apiEntry.methodCalls : [];
            const methodDetails = [];
            const seenMethodKeys = new Set();
            const defaultClassName = Array.isArray(apiRecord?.metadata?.classNames) && apiRecord.metadata.classNames.length > 0
                ? apiRecord.metadata.classNames[0]
                : '';

            methodCalls.forEach(item => {
                if (!item) return;
                const call = item.call || {};
                const methodName = item.methodName || call.methodName;
                if (!methodName) return;
                const key = `${methodName.toLowerCase()}:${call.line ?? ''}`;
                if (seenMethodKeys.has(key)) {
                    return;
                }
                seenMethodKeys.add(key);

                const summary = item.summary || {};
                const summaryInfo = extractMethodSummaryDetails(summary);
                const snippet = call.snippet ? truncateMultiline(call.snippet, 280) : '';
                methodDetails.push({
                    methodName,
                    className: summary.className || defaultClassName || '',
                    objectName: call.objectName || '',
                    summaryText: summaryInfo.summaryText,
                    expectedResultText: summaryInfo.expectedResultText,
                    params: summary.params || '',
                    isAsync: !!summary.isAsync,
                    isStatic: !!summary.isStatic,
                    snippet,
                    line: call.line ?? null
                });
            });

            methodDetails.forEach((detail, index) => {
                const callLabel = `${detail.objectName ? detail.objectName + '.' : ''}${detail.methodName}()`;
                const actionParts = [];
                const headline = detail.summaryText || `Execute ${callLabel}`;
                actionParts.push(headline);
                actionParts.push(`Method call: ${callLabel} (source: ${helperLabel})`);
                if (detail.params) {
                    actionParts.push(`Parameters: ${detail.params}`);
                }
                if (detail.snippet) {
                    actionParts.push(`Code reference:
${detail.snippet}`);
                }

                const methodStep = {
                    action: actionParts.join('\n\n'),
                    expectedResult: detail.expectedResultText || 'Helper method executes and returns the required API payload or state.',
                    context: {
                        resourceType: 'api-method',
                        resourcePath: helperLabel,
                        sequence: index + 1,
                        details: {
                            methodName: detail.methodName,
                            className: detail.className,
                            objectName: detail.objectName,
                            summaryText: detail.summaryText,
                            expectedResultText: detail.expectedResultText,
                            summary: detail.summaryText,
                            expectedResult: detail.expectedResultText,
                            params: detail.params,
                            isAsync: detail.isAsync,
                            isStatic: detail.isStatic,
                            snippet: detail.snippet,
                            line: detail.line
                        }
                    }
                };

                steps.push(methodStep);
            });

            const exportsList = Array.isArray(apiRecord?.exports)
                ? apiRecord.exports.map(item => item?.name).filter(Boolean)
                : [];
            const observedCalls = Array.isArray(apiRecord?.httpCalls)
                ? apiRecord.httpCalls.filter(call => call && call.method && call.url)
                : [];
            const sqlQueries = Array.isArray(apiRecord?.metadata?.sqlQueries)
                ? apiRecord.metadata.sqlQueries.filter(Boolean)
                : [];

            if (apiRecord) {
                const summaryParts = [`Execute API helper "${helperLabel}" to perform external integrations.`];
                if (endpoint) {
                    summaryParts.push(`Primary endpoint detected: ${endpoint}`);
                }
                if (exportsList.length > 0) {
                    summaryParts.push(`Exports referenced: ${exportsList.slice(0, 5).join(', ')}${exportsList.length > 5 ? 'â€¦' : ''}`);
                }
                if (methodDetails.length > 0) {
                    const methodPreview = methodDetails.slice(0, 5).map(detail => `${detail.methodName}${detail.summaryText ? ` â€” ${detail.summaryText}` : ''}`).join('; ');
                    summaryParts.push(`Spec-invoked methods: ${methodPreview}${methodDetails.length > 5 ? 'â€¦' : ''}`);
                }
                if (observedCalls.length > 1) {
                    summaryParts.push(`${observedCalls.length} HTTP calls detected in helper. See subsequent steps for details.`);
                }
                const summaryStep = {
                    action: summaryParts.join('\n\n'),
                    expectedResult: 'Helper executes successfully and returns data to the calling spec/flow.',
                    context: {
                        resourceType: 'api',
                        resourcePath: helperLabel,
                        endpoint
                    }
                };
                summaryStep.context.details = {
                    apiLabel: helperLabel,
                    endpoint,
                    exports: exportsList,
                    invokedMethods: methodDetails,
                    httpCalls: observedCalls.map(call => ({
                        method: (call.method || '').toUpperCase(),
                        url: call.url || '(dynamic URL)'
                    })),
                    httpCallCount: observedCalls.length,
                    sqlCount: sqlQueries.length,
                    sqlSamples: sqlQueries.slice(0, 3)
                };
                steps.push(summaryStep);
            }

            const httpCalls = observedCalls.length > 0
                ? observedCalls
                : (apiEntry?.call ? [apiEntry.call] : []);

            httpCalls.forEach((call, index) => {
                const httpStep = buildHttpCallStep({
                    call,
                    sourceLabel: helperLabel,
                    order: index + 1,
                    defaultExpectation: 'HTTP request returns expected status code and payload used by the test.'
                });
                if (httpStep) {
                    httpStep.context = Object.assign({}, httpStep.context || {}, {
                        resourceType: 'api-http',
                        resourcePath: helperLabel
                    });
                    steps.push(httpStep);
                }
            });

            sqlQueries.forEach((query, index) => {
                const sqlStep = {
                    action: `Database validation via ${helperLabel}\n\n${query}`,
                    expectedResult: 'Query executes successfully and returns expected results for validation.',
                    context: {
                            resourceType: 'api-sql',
                            resourcePath: helperLabel,
                            sequence: index + 1,
                            details: {
                                apiLabel: helperLabel,
                                query
                            }
                    }
                };
                steps.push(sqlStep);
            });

            return steps;
        }

        function buildHttpCallStep({ call, sourceLabel = 'Helper', order = 1, defaultExpectation = 'HTTP request succeeds.' }) {
            if (!call) {
                return null;
            }

            const method = (call.method || 'REQUEST').toUpperCase();
            const endpoint = call.url || '(dynamic URL computed at runtime)';
            const argumentsList = Array.isArray(call.arguments) ? call.arguments.slice(1) : [];
            const payload = call.body || (argumentsList.length > 0 ? argumentsList[0] : null);
            const hasPayload = payload && payload.length > 0;

            const sections = [`${order}. ${method} ${endpoint}`];
            if (hasPayload) {
                sections.push('Payload / Config:\n' + payload);
            }
            if (argumentsList.length > 1) {
                const extraArgs = argumentsList.slice(1).map((arg, idx) => `Arg ${idx + 3}: ${arg}`).join('\n');
                if (extraArgs) {
                    sections.push('Additional Arguments:\n' + extraArgs);
                }
            }

            const expectationParts = [defaultExpectation];
            expectationParts.push('Status code should satisfy acceptance criteria (e.g., 200/201).');
            expectationParts.push('Response schema and business assertions must pass.');

            return {
                action: `${sourceLabel} â€“ HTTP Invocation\n\n${sections.join('\n\n')}`,
                expectedResult: expectationParts.join(' '),
                context: {
                    resourceType: 'http-call',
                    method,
                    url: endpoint,
                    sourceLabel,
                    details: {
                        method,
                        url: endpoint,
                        payload: payload ? truncateMultiline(payload, 400) : null,
                        additionalArgs: argumentsList.slice(1),
                        order
                    }
                }
            };
        }

        function renumberTestSteps(testCase) {
            if (!testCase || !Array.isArray(testCase.steps)) {
                return;
            }
            testCase.steps.forEach((step, index) => {
                step.id = index + 1;
            });
        }

        function parseFileContent(content, filePath, recordLookup) {
            const testCases = [];

            const testPattern = /(test|it)(?:\.(only|skip|fixme))?\s*\(\s*(["'`])([\s\S]*?)\2\s*,\s*(async\s*)?\(([^)]*)\)\s*=>\s*\{/g;
            let match;
            while ((match = testPattern.exec(content)) !== null) {
                const quoteType = match[2];
                const rawTitle = match[3] || '';
                const normalizedTitle = normalizeTestTitle(rawTitle, quoteType);

                const bodyStartIndex = testPattern.lastIndex - 1;
                const block = extractBlockFromIndex(content, bodyStartIndex);
                if (!block) {
                    continue;
                }

                const steps = parseTestSteps(block.body, filePath, recordLookup);
                if (steps.length > 0) {
                    testCases.push({
                        title: normalizedTitle,
                        filePath,
                        steps
                    });
                }

                testPattern.lastIndex = block.endIndex + 1;
            }

            return testCases;
        }

        function normalizeTestTitle(rawTitle, quoteType) {
            if (!rawTitle) return '';
            return rawTitle.trim();
        }

        function parseTestSteps(body, filePath, recordLookup) {
            const steps = [];
            let stepCounter = 1;

            const namedStepPattern = /test\.step\s*\(\s*(["'`])([\s\S]*?)\1\s*,\s*(async\s*)?\(([^)]*)\)\s*=>\s*\{/g;
            let namedMatch;
            const namedSteps = [];
            while ((namedMatch = namedStepPattern.exec(body)) !== null) {
                const label = (namedMatch[2] || '').trim();
                const block = extractBlockFromIndex(body, namedStepPattern.lastIndex - 1);
                if (!block) {
                    continue;
                }

                const stepBody = block.body || '';
                const actionCode = extractActions(stepBody);
                const expectedResults = extractExpectations(stepBody);
                const enrichedAction = enrichStepWithHelperDetails(stepBody, label, recordLookup);
                
                namedSteps.push({
                    id: stepCounter++,
                    action: enrichedAction,
                    expectedResult: expectedResults.join('\n') || 'Step completes without errors.'
                });

                namedStepPattern.lastIndex = block.endIndex + 1;
            }

            if (namedSteps.length > 0) {
                steps.push(...namedSteps);
                return steps;
            }

            // Look for // Step X: comments first
            const stepCommentPattern = /\/\/\s*Step\s*\d+[:\s]*([^\n]*)/gi;
            const stepChunks = body.split(stepCommentPattern).filter(chunk => chunk.trim());

            if (stepChunks.length > 1) {
                // Parse step-based comments
                for (let i = 1; i < stepChunks.length; i += 2) {
                    const stepDescription = stepChunks[i - 1].trim();
                    const stepCode = stepChunks[i].trim();

                    const actionCode = extractActions(stepCode);
                    const expectedResults = extractExpectations(stepCode);
                    const enrichedAction = enrichStepWithHelperDetails(stepCode, stepDescription, recordLookup);

                    steps.push({
                        id: stepCounter++,
                        action: enrichedAction,
                        expectedResult: expectedResults.join('\n') || 'Execution completes without error.'
                    });
                }
            } else {
                // Fallback: parse based on await statements
                const awaitStatements = body.match(/await\s+[^;]+;/g) || [];
                if (awaitStatements.length > 0) {
                    for (const statement of awaitStatements.slice(0, 10)) { // Limit to 10 steps
                        const enrichedAction = enrichStepWithHelperDetails(statement, '', recordLookup);
                        const expectation = extractExpectationFromAction(statement);
                        steps.push({
                            id: stepCounter++,
                            action: enrichedAction,
                            expectedResult: expectation || 'Action completes successfully.'
                        });
                    }
                }
            }

            return steps;
        }

        function enrichStepWithHelperDetails(stepCode, label, recordLookup) {
            if (!stepCode || !recordLookup) {
                return label || `Execute: ${stepCode.trim()}`;
            }

            // Extract method calls from the step code
            const methodCalls = extractObjectMethodCalls(stepCode);
            if (!methodCalls || methodCalls.length === 0) {
                return label || `Execute: ${stepCode.trim()}`;
            }

            const enrichedParts = [];
            if (label) {
                enrichedParts.push(label);
            }

            // Find helper method details for each method call
            for (const call of methodCalls) {
                const objectLower = (call.objectName || '').toLowerCase();
                const methodLower = (call.methodName || '').toLowerCase();

                let helperRecord = null;
                let methodSummary = null;

                // Search through all records to find matching helper
                for (const [_, record] of recordLookup) {
                    if (!record || record.detectedType === 'spec') continue;
                    
                    const aliasNames = collectAliasNames(record);
                    const callableNames = collectCallableNames(record);
                    
                    // Check if this record has the method and matches the object name
                    if (callableNames.has(methodLower) && 
                        (aliasNames.has(objectLower) || !objectLower)) {
                        helperRecord = record;
                        methodSummary = findMethodSummaryForCall(record, call);
                        break;
                    }
                }

                if (helperRecord && methodSummary) {
                    const methodTitle = `${call.objectName ? call.objectName + '.' : ''}${call.methodName}()`;
                    const functionality = methodSummary.summary || 'Performs helper operations';
                    const helperType = helperRecord.detectedType === 'flow' ? 'Flow Helper' : 'Page/API Helper';
                    
                    enrichedParts.push(`${methodTitle} â€” ${helperType}`);
                    enrichedParts.push(`Functionality: ${functionality}`);
                    
                    if (methodSummary.params) {
                        enrichedParts.push(`Parameters: ${methodSummary.params}`);
                    }
                } else {
                    // Fallback for unmatched method calls
                    const methodTitle = `${call.objectName ? call.objectName + '.' : ''}${call.methodName}()`;
                    enrichedParts.push(`${methodTitle} â€” Helper Method`);
                    enrichedParts.push(`Execute helper functionality`);
                }
            }

            // Add code reference if no label was provided
            if (!label && stepCode.trim()) {
                enrichedParts.push(`Code: ${stepCode.trim()}`);
            }

            return enrichedParts.length > 0 ? enrichedParts.join('\n\n') : `Execute: ${stepCode.trim()}`;
        }

        function extractActions(code) {
            return (code.match(/await\s+(?!expect)[^;]+;/g) || [])
                .map(line => line.trim())
                .join('\n');
        }

        function extractExpectations(code) {
            return (code.match(/await\s+expect\s*\([^)]+\)\s*\.[^(]+\([^)]*\);/g) || [])
                .map(parseExpectation)
                .filter(exp => exp);
        }

        function extractExpectationFromAction(action) {
            const expectPattern = /await\s+expect\s*\([^)]+\)\s*\.(\w+)\s*\(([^)]*)\)/;
            const match = action.match(expectPattern);
            if (match) {
                return parseExpectation(action);
            }
            return null;
        }

        function parseExpectation(line) {
            line = line.trim();

            // toHaveText
            if (line.includes('toHaveText')) {
                const match = line.match(/toHaveText\(['"]([^'"]*)['"]\)/);
                return match ? `Text content should be: "${match[1]}"` : 'Text content should match expectation.';
            }

            // toBeVisible, toBeHidden
            if (line.includes('toBeVisible')) return 'Element should be visible.';
            if (line.includes('toBeHidden')) return 'Element should be hidden.';

            // toContainText
            if (line.includes('toContainText')) {
                const match = line.match(/toContainText\(['"]([^'"]*)['"]\)/);
                return match ? `Element should contain text: "${match[1]}"` : 'Element should contain expected text.';
            }

            // toHaveURL
            if (line.includes('toHaveURL')) {
                const match = line.match(/toHaveURL\(['"]([^'"]*)['"]\)/);
                return match ? `Page URL should be: "${match[1]}"` : 'Page should be at expected URL.';
            }

            // toHaveValue, toHaveAttribute
            if (line.includes('toHaveValue')) {
                const match = line.match(/toHaveValue\(['"]([^'"]*)['"]\)/);
                return match ? `Input should have value: "${match[1]}"` : 'Input should have expected value.';
            }

            return 'Assertion should pass.';
        }

        function displayResults(parseResults) {
            results.classList.remove('hidden');
            const { stats, testCases } = parseResults;
            const analysis = parseResults.analysis || {};
            const aggregateStats = analysis.aggregateStats || {};
            const hasTestCases = Array.isArray(testCases) && testCases.length > 0;

            const exportButtonHtml = hasTestCases
                ? `<button id="export-results-button" class="px-4 py-2 bg-blue-600 text-white text-sm font-semibold rounded-lg shadow-sm hover:bg-blue-700 transition-colors">Export CSV</button>`
                : `<button id="export-results-button" class="px-4 py-2 bg-slate-200 text-slate-500 text-sm font-semibold rounded-lg cursor-not-allowed" disabled>Export CSV</button>`;

            resultsContent.innerHTML = `
                <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-6">
                    <div>
                        <h4 class="text-lg font-semibold text-slate-800">Analysis Summary</h4>
                        <p class="text-sm text-slate-500">${hasTestCases ? `${testCases.length} test case${testCases.length === 1 ? '' : 's'} ready for export.` : 'No exportable test cases were detected.'}</p>
                    </div>
                    ${exportButtonHtml}
                </div>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-blue-600">${stats.totalFiles}</div>
                        <div class="text-sm text-blue-600">Files Scanned</div>
                    </div>
                    <div class="bg-green-50 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-green-600">${stats.totalTests}</div>
                        <div class="text-sm text-green-600">Tests Found</div>
                    </div>
                    <div class="bg-purple-50 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-purple-600">${stats.filesWithTests}</div>
                        <div class="text-sm text-purple-600">Files with Tests</div>
                    </div>
                    <div class="bg-orange-50 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-orange-600">${stats.parsingErrors}</div>
                        <div class="text-sm text-orange-600">Parse Errors</div>
                    </div>
                </div>
                ${renderAggregateAnalysis(aggregateStats)}
                <div class="border-t pt-4">
                    <h4 class="font-semibold mb-2">Generated ${testCases.length} Test Cases:</h4>
                    <div class="max-h-60 overflow-y-auto space-y-2">
                        ${testCases.slice(0, 10).map((tc, index) => {
                            const safeTitle = escapeHtml(tc.title || 'Untitled test case');
                            const stepCount = Array.isArray(tc.steps) ? tc.steps.length : 0;
                            const stepLabel = `${stepCount} step${stepCount === 1 ? '' : 's'}`;
                            const safeStepLabel = escapeHtml(stepLabel);
                            return `
                                <button type="button" class="test-case-preview-row w-full text-left bg-slate-50 p-3 rounded border border-transparent hover:border-blue-400 hover:shadow transition-all focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-500" data-test-case-index="${index}">
                                    <div class="flex items-center justify-between gap-3">
                                        <span class="font-medium text-slate-800 truncate">${safeTitle}</span>
                                        <span class="text-[11px] inline-flex items-center px-2 py-1 rounded-full bg-blue-100 text-blue-700 font-semibold">Preview</span>
                                    </div>
                                    <div class="text-sm text-slate-600 mt-1">${safeStepLabel}</div>
                                </button>
                            `;
                        }).join('')}
                        ${testCases.length > 10 ? `<div class="text-sm text-slate-500">... and ${testCases.length - 10} more</div>` : ''}
                    </div>
                </div>
                ${renderRelationshipSummary(analysis)}
                ${renderTestCaseEnrichmentSummary(analysis.testCaseEnrichmentSummary)}
                ${renderUnresolvedReferences(analysis.unresolvedReferences)}
            `;

            const exportResultsButton = document.getElementById('export-results-button');
            if (exportResultsButton) {
                exportResultsButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();

                    if (!hasTestCases || !currentParseResults || !currentParseResults.testCases || currentParseResults.testCases.length === 0) {
                        updateStatus('No test cases available to export.', 'warning');
                        return;
                    }

                    showConfigModal();
                });
            }

            const previewRows = Array.from(resultsContent.querySelectorAll('.test-case-preview-row'));
            if (previewRows.length > 0) {
                previewRows.forEach(row => {
                    row.addEventListener('click', () => {
                        const index = parseInt(row.getAttribute('data-test-case-index'), 10);
                        if (!Number.isNaN(index) && testCases[index]) {
                            showTestCasePreviewModal(testCases[index], index + 1);
                        }
                    });
                });
            }
        }

        function showTestCasePreviewModal(testCase, ordinalPosition = null) {
            if (!previewModal || !previewModalContent) {
                return;
            }

            const steps = Array.isArray(testCase?.steps) ? testCase.steps : [];
            const title = testCase?.title || 'Test Case Preview';

            if (previewModalTitle) {
                previewModalTitle.textContent = title;
            }

            if (previewModalSubtitle) {
                const stepLabel = `${steps.length} step${steps.length === 1 ? '' : 's'}`;
                previewModalSubtitle.textContent = ordinalPosition
                    ? `${stepLabel} â€¢ Test Case ${ordinalPosition}`
                    : stepLabel;
            }

            previewModalContent.innerHTML = renderTestCasePreviewContent(testCase);
            updateAiPreviewPanel(null);
            clearPreviewModalStatus();
            updateAiEvaluationButtonState();
            previewModal.classList.remove('hidden');
            previewModal.classList.remove('pointer-events-none');
            previewModal.classList.add('pointer-events-auto');

            document.body.style.overflow = 'hidden';
            activePreviewTestCaseIndex = ordinalPosition !== null ? ordinalPosition - 1 : null;
        }

        function hidePreviewModal() {
            if (!previewModal) {
                return;
            }

            previewModal.classList.add('hidden');
            previewModal.classList.add('pointer-events-none');
            previewModal.classList.remove('pointer-events-auto');
            document.body.style.removeProperty('overflow');

            activePreviewTestCaseIndex = null;
            aiEvaluationInFlight = false;
            clearPreviewModalStatus();
            updateAiEvaluationButtonState();
            if (previewModalContent) {
                previewModalContent.innerHTML = '';
            }
        }

        function handlePreviewModalKeydown(event) {
            if (event.key !== 'Escape') {
                return;
            }
            if (!previewModal || previewModal.classList.contains('hidden')) {
                return;
            }
            event.preventDefault();
            hidePreviewModal();
        }

        function renderTestCasePreviewContent(testCase) {
            if (!testCase) {
                return '<div class="text-sm text-slate-500">No data is available for this test case.</div>';
            }

            const steps = Array.isArray(testCase.steps) ? testCase.steps : [];
            if (steps.length === 0) {
                return '<div class="text-sm text-slate-500">This test case does not contain any recorded steps.</div>';
            }

            const stepsMarkup = steps.map((step, index) => renderPreviewStep(step, index)).join('');
            return `
                <div class="space-y-4">
                    <div id="preview-ai-panel" class="hidden bg-slate-100 border border-slate-200 text-slate-700 rounded-lg p-4 text-sm"></div>
                    <div class="space-y-3">
                        ${stepsMarkup}
                    </div>
                </div>
            `;
        }

        function renderPreviewStep(step, index) {
            const action = formatPreviewText(step?.action || 'No action documented.');
            const expectation = formatPreviewText(step?.expectedResult || 'Step completes without errors.');
            const contextBadges = renderPreviewContextBadges(step?.context);
            return `
                <div class="bg-white border border-slate-200 rounded-lg shadow-sm p-4 space-y-3">
                    <div class="flex items-center justify-between gap-3">
                        <span class="text-xs uppercase tracking-wide text-slate-500">Step ${index + 1}</span>
                        ${contextBadges}
                    </div>
                    <div class="text-sm font-semibold text-slate-800 leading-relaxed whitespace-pre-wrap">${action}</div>
                    <div class="text-sm text-slate-600 whitespace-pre-wrap"><span class="font-semibold text-slate-700">Expected:</span> ${expectation}</div>
                </div>
            `;
        }

        function renderPreviewContextBadges(context) {
            if (!context || typeof context !== 'object') {
                return '';
            }

            const badges = [];
            if (context.resourceType) {
                badges.push(`<span class="inline-flex items-center px-2 py-1 rounded-full bg-slate-200 text-slate-700 text-[11px] font-medium">${escapeHtml(String(context.resourceType))}</span>`);
            }
            if (context.resourcePath) {
                badges.push(`<span class="inline-flex items-center px-2 py-1 rounded-full bg-slate-100 text-slate-600 text-[11px]">${escapeHtml(String(context.resourcePath))}</span>`);
            }
            if (typeof context.sequence === 'number') {
                badges.push(`<span class="inline-flex items-center px-2 py-1 rounded-full bg-blue-100 text-blue-700 text-[11px]">#${context.sequence}</span>`);
            }
            return badges.length > 0 ? `<div class="flex flex-wrap gap-2">${badges.join('')}</div>` : '';
        }

        function formatPreviewText(value) {
            const normalized = typeof value === 'string' ? value : String(value ?? '');
            return escapeHtml(normalized).replace(/\r?\n/g, '<br/>');
        }

        function renderAggregateAnalysis(stats) {
            if (!stats || Object.keys(stats).length === 0) {
                return '';
            }

            const cards = [
                { label: 'Items Selected', value: stats.totalSelections ?? 0, color: 'bg-sky-50', text: 'text-sky-600' },
                { label: 'Spec Files', value: stats.specFiles ?? 0, color: 'bg-indigo-50', text: 'text-indigo-600' },
                { label: 'Flow Files', value: stats.flowFiles ?? 0, color: 'bg-emerald-50', text: 'text-emerald-600' },
                { label: 'API Files', value: stats.apiFiles ?? 0, color: 'bg-rose-50', text: 'text-rose-600' }
            ];

            return `
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                    ${cards.map(card => `
                        <div class="${card.color} p-4 rounded-lg">
                            <div class="text-2xl font-bold ${card.text}">${card.value}</div>
                            <div class="text-sm ${card.text}">${card.label}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderTestCaseEnrichmentSummary(summary) {
            if (!Array.isArray(summary) || summary.length === 0) {
                return '';
            }

            const totalCases = summary.length;
            const totalSteps = summary.reduce((sum, item) => sum + (item?.addedSteps || 0), 0);
            const sampleItems = summary.slice(0, 3).map(item => {
                const title = escapeHtml(item.caseTitle || 'Unnamed test case');
                const steps = item?.addedSteps || 0;
                return `<li>${title} Â· ${steps} supporting step${steps === 1 ? '' : 's'}</li>`;
            }).join('');

            return `
                <div class="mt-6 bg-emerald-50 border border-emerald-200 text-emerald-700 rounded-lg px-4 py-3">
                    <div class="font-semibold">Supporting steps added</div>
                    <div class="text-sm mt-1">Augmented ${totalCases} test case${totalCases === 1 ? '' : 's'} with ${totalSteps} supporting step${totalSteps === 1 ? '' : 's'} sourced from API/Page helpers.</div>
                    ${sampleItems ? `<ul class="mt-2 text-xs list-disc list-inside space-y-1">${sampleItems}</ul>` : ''}
                </div>
            `;
        }

        function renderRelationshipSummary(analysis) {
            if (!analysis || !analysis.relationships || analysis.relationships.length === 0) {
                return `
                    <div class="mt-6 border-t pt-4">
                        <h4 class="font-semibold mb-2">Spec â†” Flow â†” API Relationships</h4>
                        <p class="text-sm text-slate-500">No relationships were detected among the uploaded folders. Add corresponding Flow or API folders if you want to map dependencies.</p>
                    </div>
                `;
            }

            const relationshipCards = analysis.relationships.map((relationship, index) => {
                const flowList = relationship.viaFlows && relationship.viaFlows.length > 0
                    ? relationship.viaFlows.map(entry => {
                        const path = typeof entry === 'string'
                            ? entry
                            : (entry?.path || '');
                        const methods = entry && typeof entry === 'object' && Array.isArray(entry.methodCalls)
                            ? entry.methodCalls
                            : [];
                        let methodPreview = '';
                        if (methods.length > 0) {
                            const methodNames = methods.map(method => method?.methodName).filter(Boolean);
                            if (methodNames.length > 0) {
                                const preview = methodNames.slice(0, 2).map(name => escapeHtml(name)).join(', ');
                                const suffix = methodNames.length > 2 ? 'â€¦' : '';
                                methodPreview = ` <span class="ml-1 text-[10px] text-emerald-700/80">(${preview}${suffix})</span>`;
                            }
                        }
                        const label = path || 'Flow helper';
                        return `<span class="inline-flex items-center px-2 py-1 rounded-full bg-emerald-100 text-emerald-700 text-xs font-medium">${escapeHtml(label)}${methodPreview}</span>`;
                    }).join(' ')
                    : '<span class="text-sm text-slate-500">None detected</span>';

                const apiList = relationship.toApis && relationship.toApis.length > 0
                    ? relationship.toApis.map(api => renderApiInvocation(api)).join('')
                    : '<span class="text-sm text-slate-500">No API calls detected</span>';

                const evidenceList = renderEvidencePreview(relationship.evidence);

                return `
                    <div class="bg-slate-50 border border-slate-200 rounded-lg p-4 space-y-3">
                        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
                            <div>
                                <div class="text-xs uppercase tracking-wide text-slate-500">Spec Case</div>
                                <div class="text-sm font-semibold text-slate-800">${escapeHtml(relationship.fromFile)}</div>
                            </div>
                            <div class="text-xs uppercase tracking-wide text-slate-500">Confidence
                                <span class="ml-2 px-2 py-1 rounded-full bg-emerald-100 text-emerald-700 font-semibold">
                                    ${formatConfidence(relationship.confidence)}
                                </span>
                            </div>
                        </div>
                        <div class="grid md:grid-cols-2 gap-3">
                            <div>
                                <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">Flows Used</div>
                                <div class="flex flex-wrap gap-2">${flowList}</div>
                            </div>
                            <div>
                                <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">API Calls</div>
                                <div class="space-y-1">${apiList}</div>
                            </div>
                        </div>
                        ${evidenceList}
                    </div>
                `;
            }).join('');

            return `
                <div class="mt-6 border-t pt-4 space-y-3">
                    <div class="flex items-center justify-between">
                        <h4 class="font-semibold">Spec â†” Flow â†” API Relationships</h4>
                        <span class="text-xs text-slate-500">${analysis.relationships.length} relationship${analysis.relationships.length === 1 ? '' : 's'}</span>
                    </div>
                    <div class="space-y-4">
                        ${relationshipCards}
                    </div>
                </div>
            `;
        }

        function renderApiInvocation(api) {
            if (!api) return '';
            if (!api.apiFile && !api.url) {
                return '<div class="text-sm text-slate-500">Unresolved API reference</div>';
            }

            const method = api.method && api.method !== 'UNKNOWN'
                ? `<span class="inline-flex items-center px-2 py-0.5 rounded-full bg-blue-100 text-blue-700 text-xs font-semibold mr-2">${escapeHtml(api.method)}</span>`
                : '';

            const target = api.apiFile
                ? `<span class="font-medium text-slate-800">${escapeHtml(api.apiFile)}</span>`
                : `<span class="font-medium text-slate-800">${escapeHtml(api.url || '')}</span>`;

            const matchedBy = api.matchedBy ? `<span class="text-xs text-slate-500">via ${escapeHtml(api.matchedBy)}</span>` : '';
            const methodNames = Array.isArray(api.methodCalls)
                ? api.methodCalls.map(item => item?.methodName).filter(Boolean)
                : [];
            const methodBadge = methodNames.length > 0
                ? `<span class="ml-2 text-[11px] text-slate-500">methods: ${methodNames.slice(0, 3).map(name => escapeHtml(name)).join(', ')}${methodNames.length > 3 ? 'â€¦' : ''}</span>`
                : '';

            return `
                <div class="text-sm text-slate-600">
                    ${method}${target} ${matchedBy}${methodBadge}
                </div>
            `;
        }

        function renderEvidencePreview(evidence) {
            if (!evidence || evidence.length === 0) {
                return '';
            }

            const preview = evidence.slice(0, 3).map(item => `
                <div class="text-xs text-slate-500 bg-white/40 border border-slate-200 rounded px-3 py-2">
                    <div class="font-medium text-slate-600">${escapeHtml(item.description || item.type)}</div>
                    <div class="mt-1 font-mono text-[11px] text-slate-500 truncate">${escapeHtml(item.snippet || '')}</div>
                    ${item.location && item.location.file ? `<div class="mt-1 text-[10px] text-slate-400">${escapeHtml(item.location.file)}${item.location.line ? ` Â· Line ${item.location.line}` : ''}</div>` : ''}
                </div>
            `).join('');

            const moreCount = Math.max(0, evidence.length - 3);
            const moreBadge = moreCount > 0 ? `<div class="text-xs text-slate-400">+${moreCount} more evidence item${moreCount === 1 ? '' : 's'}</div>` : '';

            return `
                <div class="border border-slate-200 rounded-lg bg-slate-100/60 px-3 py-2 space-y-2">
                    <div class="text-xs uppercase tracking-wide text-slate-500">Evidence</div>
                    <div class="space-y-2">${preview}</div>
                    ${moreBadge}
                </div>
            `;
        }

        function formatConfidence(score) {
            if (typeof score !== 'number' || Number.isNaN(score)) {
                return 'N/A';
            }
            const clamped = Math.max(0, Math.min(1, score));
            return `${Math.round(clamped * 100)}%`;
        }

        function renderUnresolvedReferences(references) {
            if (!references || references.length === 0) {
                return '';
            }

            const items = references.slice(0, 10).map(ref => `
                <div class="bg-amber-50 border border-amber-200 rounded-lg px-3 py-2 text-xs text-amber-700">
                    <div class="font-semibold">${escapeHtml(ref.reference)}</div>
                    <div>${escapeHtml(ref.sourceFile || '')}</div>
                    <div class="text-[10px] uppercase tracking-wide mt-1">${escapeHtml(ref.reason)}</div>
                </div>
            `).join('');

            const extra = references.length > 10
                ? `<div class="text-xs text-slate-400 mt-2">+${references.length - 10} more unresolved reference${references.length - 10 === 1 ? '' : 's'}.</div>`
                : '';

            return `
                <div class="mt-6 border-t pt-4">
                    <h4 class="font-semibold mb-2">Unresolved References</h4>
                    <p class="text-xs text-slate-500 mb-3">We couldn't match these imports or calls to any of the selected folders. Adjust folder roles or add missing files if they should be linked.</p>
                    <div class="space-y-2">${items}</div>
                    ${extra}
                </div>
            `;
        }

        function showConfigModal() {
            if (!configModal) return;

            console.log('Opening config modal...');
            configModal.classList.remove('hidden');
            configModal.classList.remove('pointer-events-none');
            configModal.classList.add('pointer-events-auto');

            const pathDisplay = document.getElementById('save-path-display');
            const saveButton = document.getElementById('config-save');

            if (!selectedSaveDirectory && pathDisplay) {
                pathDisplay.value = 'Will use save dialog if not specified';
            }

            if (saveButton) {
                saveButton.disabled = false;
            }

            console.log('Config modal should now be visible');
        }

        function hideConfigModal() {
            if (!configModal) return;
            configModal.classList.add('hidden');
            configModal.classList.add('pointer-events-none');
            configModal.classList.remove('pointer-events-auto');
        }

        async function saveConfigAndExport() {
            if (!currentParseResults || currentParseResults.testCases.length === 0) {
                updateStatus('No test cases available to export.', 'error');
                hideConfigModal();
                return;
            }

            hideConfigModal();
            updateStatus('Generating CSV file...', 'info');

            try {
                const csvContent = convertToCsv(currentParseResults.testCases, azureConfig);
                let result;

                // Check if Electron API is available
                if (!window.electronAPI) {
                    console.log('Electron API not available, using browser download');
                    // Fallback to browser download
                    downloadCSVInBrowser(csvContent);
                    return;
                }

                if (selectedSaveDirectory && window.electronAPI.saveCsvToDirectory) {
                    // Save to selected directory
                    console.log('Saving to selected directory:', selectedSaveDirectory);
                    result = await window.electronAPI.saveCsvToDirectory(csvContent, 'azure-test-cases', selectedSaveDirectory);
                } else if (window.electronAPI.saveCsv) {
                    // Use the standard save dialog
                    console.log('No directory selected, using save dialog');
                    result = await window.electronAPI.saveCsv(csvContent, 'azure-test-cases');
                } else {
                    // Fallback to browser download
                    console.log('Electron save functions not available, using browser download');
                    downloadCSVInBrowser(csvContent);
                    return;
                }

                if (result && result.success) {
                    updateStatus(result.message, 'success');
                    selectedSaveDirectory = null; // Reset after successful save
                    updateWorkflowStage('exported');
                } else {
                    updateStatus(result ? result.message : 'Save operation failed', 'error');
                }
            } catch (error) {
                console.error('Export error:', error);
                updateStatus(`Export failed: ${error.message}. Trying browser download...`, 'warning');
                
                // Fallback to browser download
                try {
                    const csvContent = convertToCsv(currentParseResults.testCases, azureConfig);
                    downloadCSVInBrowser(csvContent);
                } catch (fallbackError) {
                    updateStatus(`All save methods failed: ${fallbackError.message}`, 'error');
                }
            }
        }

        function downloadCSVInBrowser(csvContent) {
            try {
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                link.setAttribute('href', url);
                link.setAttribute('download', `azure-test-cases-${Date.now()}.csv`);
                link.style.visibility = 'hidden';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                updateStatus('CSV file downloaded successfully via browser!', 'success');
                updateWorkflowStage('exported');
                console.log('CSV downloaded via browser fallback');
            } catch (error) {
                updateStatus(`Browser download failed: ${error.message}`, 'error');
                console.error('Browser download error:', error);
            }
        }

        function truncateMultiline(value, maxLength = 280) {
            if (!value) return '';
            const normalized = String(value).trim();
            if (normalized.length <= maxLength) {
                return normalized;
            }
            return normalized.slice(0, maxLength - 1) + 'â€¦';
        }

        function isSupportingStep(step) {
            if (!step) return false;
            const source = String(step.source || '').toLowerCase();
            if (source.startsWith('relationship-')) {
                return true;
            }
            const ctxType = String(step.context?.resourceType || '').toLowerCase();
            if (!ctxType) return false;
            return ctxType.includes('flow') || ctxType.includes('api') || ctxType.includes('http') || ctxType.includes('sql');
        }

        function buildSyntheticSupportingStepsFromContext(context) {
            const synthetic = [];
            if (!context) {
                return synthetic;
            }

            (context.flows || []).forEach(flow => {
                synthetic.push({
                    source: 'relationship-flow',
                    context: {
                        resourceType: 'flow',
                        resourcePath: flow.label,
                        details: {
                            flowLabel: flow.label,
                            functionNames: Array.isArray(flow.functionNames) ? flow.functionNames : [],
                            invokedMethods: Array.isArray(flow.methods) ? flow.methods : [],
                            httpCalls: Array.isArray(flow.httpCalls) ? flow.httpCalls : [],
                            sqlCount: Array.isArray(flow.sqlQueries) ? flow.sqlQueries.length : 0,
                            sqlSamples: Array.isArray(flow.sqlQueries) ? flow.sqlQueries.slice(0, 3) : []
                        }
                    }
                });
            });

            (context.apis || []).forEach(api => {
                synthetic.push({
                    source: 'relationship-api',
                    context: {
                        resourceType: 'api',
                        resourcePath: api.label,
                        endpoint: api.endpoint,
                        details: {
                            apiLabel: api.label,
                            endpoint: api.endpoint,
                            exports: Array.isArray(api.exports) ? api.exports : [],
                            invokedMethods: Array.isArray(api.methods) ? api.methods : [],
                            httpCalls: Array.isArray(api.httpCalls) ? api.httpCalls : [],
                            sqlCount: Array.isArray(api.sqlQueries) ? api.sqlQueries.length : 0,
                            sqlSamples: Array.isArray(api.sqlQueries) ? api.sqlQueries.slice(0, 3) : []
                        }
                    }
                });
            });

            (context.httpCalls || []).forEach(call => {
                synthetic.push({
                    source: 'relationship-api',
                    context: {
                        resourceType: 'http-call',
                        method: call.method,
                        url: call.url,
                        sourceLabel: Array.isArray(call.sources) ? call.sources.join(', ') : call.sources,
                        details: {
                            method: call.method,
                            url: call.url,
                            payload: Array.isArray(call.payloads) && call.payloads.length > 0 ? call.payloads[0] : null,
                            additionalArgs: [],
                            sourceLabel: Array.isArray(call.sources) ? call.sources.join(', ') : call.sources
                        }
                    }
                });
            });

            (context.sqlQueries || []).forEach(entry => {
                synthetic.push({
                    source: 'relationship-api',
                    context: {
                        resourceType: 'sql',
                        resourcePath: entry.origin,
                        details: {
                            apiLabel: entry.origin,
                            flowLabel: entry.origin,
                            query: entry.query
                        }
                    }
                });
            });

            return synthetic;
        }

        function buildContextSummarySteps(supportingSteps, fallbackContext) {
            let stepsForSummary = Array.isArray(supportingSteps) ? supportingSteps.filter(Boolean) : [];
            if ((!stepsForSummary || stepsForSummary.length === 0) && fallbackContext) {
                stepsForSummary = buildSyntheticSupportingStepsFromContext(fallbackContext);
            }

            if (!Array.isArray(stepsForSummary) || stepsForSummary.length === 0) {
                return [];
            }

            const flowSummaries = new Map();
            const apiSummaries = new Map();
            const httpSummaries = new Map();
            const sqlSummaries = [];

            stepsForSummary.forEach(step => {
                if (!step) return;
                const ctx = step.context || {};
                const ctxType = String(ctx.resourceType || '').toLowerCase();
                const details = ctx.details || {};

                if (ctxType === 'flow') {
                    const key = ctx.resourcePath || details.flowLabel || `flow-${flowSummaries.size + 1}`;
                    if (!flowSummaries.has(key)) {
                        flowSummaries.set(key, {
                            label: details.flowLabel || ctx.resourcePath || key,
                            functions: [],
                            httpCalls: [],
                            sqlCount: 0,
                            sqlSamples: [],
                            rawAction: step.action || '',
                            methods: new Map()
                        });
                    }
                    const entry = flowSummaries.get(key);
                    if (Array.isArray(details.functionNames) && entry.functions.length === 0) {
                        entry.functions = details.functionNames;
                    }
                    if (Array.isArray(details.httpCalls) && entry.httpCalls.length === 0) {
                        entry.httpCalls = details.httpCalls;
                    }
                    if (!entry.sqlCount && details.sqlCount) {
                        entry.sqlCount = details.sqlCount;
                    }
                    if (Array.isArray(details.sqlSamples) && entry.sqlSamples.length === 0) {
                        entry.sqlSamples = details.sqlSamples;
                    }
                    const invoked = Array.isArray(details.invokedMethods) ? details.invokedMethods : [];
                    invoked.forEach(method => {
                        const methodName = method?.methodName;
                        if (!methodName) return;
                        entry.methods.set(methodName.toLowerCase(), method);
                    });
                    return;
                }

                if (ctxType === 'flow-method') {
                    const key = ctx.resourcePath || details.flowLabel || `flow-${flowSummaries.size + 1}`;
                    if (!flowSummaries.has(key)) {
                        flowSummaries.set(key, {
                            label: details.flowLabel || ctx.resourcePath || key,
                            functions: [],
                            httpCalls: [],
                            sqlCount: 0,
                            sqlSamples: [],
                            rawAction: '',
                            methods: new Map()
                        });
                    }
                    const entry = flowSummaries.get(key);
                    const methodName = details.methodName || ctx.methodName;
                    if (methodName) {
                        entry.methods.set(methodName.toLowerCase(), {
                            methodName,
                            summary: details.summary || '',
                            objectName: details.objectName || '',
                            className: details.className || ''
                        });
                    }
                    return;
                }

                if (ctxType === 'api') {
                    const key = ctx.resourcePath || details.apiLabel || `api-${apiSummaries.size + 1}`;
                    if (!apiSummaries.has(key)) {
                        apiSummaries.set(key, {
                            label: details.apiLabel || ctx.resourcePath || key,
                            endpoint: details.endpoint || ctx.endpoint || '',
                            exports: [],
                            httpCalls: [],
                            sqlCount: 0,
                            sqlSamples: [],
                            rawAction: step.action || '',
                            methods: new Map()
                        });
                    }
                    const entry = apiSummaries.get(key);
                    if (Array.isArray(details.exports) && entry.exports.length === 0) {
                        entry.exports = details.exports;
                    }
                    if (Array.isArray(details.httpCalls) && entry.httpCalls.length === 0) {
                        entry.httpCalls = details.httpCalls;
                    }
                    if (!entry.sqlCount && details.sqlCount) {
                        entry.sqlCount = details.sqlCount;
                    }
                    if (Array.isArray(details.sqlSamples) && entry.sqlSamples.length === 0) {
                        entry.sqlSamples = details.sqlSamples;
                    }
                    const invoked = Array.isArray(details.invokedMethods) ? details.invokedMethods : [];
                    invoked.forEach(method => {
                        const methodName = method?.methodName;
                        if (!methodName) return;
                        entry.methods.set(methodName.toLowerCase(), method);
                    });
                    return;
                }

                if (ctxType === 'api-method') {
                    const key = ctx.resourcePath || details.apiLabel || `api-${apiSummaries.size + 1}`;
                    if (!apiSummaries.has(key)) {
                        apiSummaries.set(key, {
                            label: details.apiLabel || ctx.resourcePath || key,
                            endpoint: details.endpoint || ctx.endpoint || '',
                            exports: [],
                            httpCalls: [],
                            sqlCount: 0,
                            sqlSamples: [],
                            rawAction: '',
                            methods: new Map()
                        });
                    }
                    const entry = apiSummaries.get(key);
                    const methodName = details.methodName || ctx.methodName;
                    if (methodName) {
                        entry.methods.set(methodName.toLowerCase(), {
                            methodName,
                            summaryText: details.summaryText || details.summary || '',
                            expectedResultText: details.expectedResultText || details.expectedResult || '',
                            summary: details.summary || details.summaryText || '',
                            objectName: details.objectName || '',
                            className: details.className || ''
                        });
                    }
                    return;
                }

                if (ctxType.includes('http')) {
                    const method = (ctx.method || details.method || 'REQUEST').toUpperCase();
                    const url = ctx.url || details.url || '(dynamic URL)';
                    const key = `${method}:${url}`;
                    if (!httpSummaries.has(key)) {
                        httpSummaries.set(key, {
                            method,
                            url,
                            source: ctx.sourceLabel || details.sourceLabel || ctx.resourcePath || '',
                            payload: details.payload || null,
                            additionalArgs: Array.isArray(details.additionalArgs) ? details.additionalArgs : [],
                            originalAction: step.action || ''
                        });
                    }
                    return;
                }

                if (ctxType.includes('sql')) {
                    sqlSummaries.push({
                        origin: ctx.resourcePath || details.flowLabel || details.apiLabel || 'Helper',
                        query: details.query || step.action || ''
                    });
                }
            });

            const summarySteps = [];

            if (flowSummaries.size > 0) {
                const lines = [];
                flowSummaries.forEach(entry => {
                    const segments = [];
                    if (entry.functions && entry.functions.length > 0) {
                        segments.push(`Functions: ${entry.functions.join(', ')}`);
                    }
                    if (entry.methods && entry.methods.size > 0) {
                        const methodPreview = Array.from(entry.methods.values()).slice(0, 4)
                            .map(method => {
                                const summary = method.summaryText || method.summary || '';
                                return summary ? `${method.methodName} â€” ${summary}` : method.methodName;
                            })
                            .join('; ');
                        segments.push(`Methods: ${methodPreview}${entry.methods.size > 4 ? ` (+${entry.methods.size - 4} more)` : ''}`);
                    }
                    if (entry.httpCalls && entry.httpCalls.length > 0) {
                        const preview = entry.httpCalls.slice(0, 4).map(call => `${call.method} ${call.url}`).join('; ');
                        segments.push(`HTTP: ${preview}${entry.httpCalls.length > 4 ? ` (+${entry.httpCalls.length - 4} more)` : ''}`);
                    }
                    if (entry.sqlCount) {
                        segments.push(`Database queries: ${entry.sqlCount}`);
                    }
                    const detailLine = segments.length > 0 ? ` â€” ${segments.join(' | ')}` : '';
                    lines.push(`â€¢ ${entry.label}${detailLine}`);
                });

                summarySteps.push({
                    action: ['Flow orchestration helpers engaged during this test:', lines.join('\n')].join('\n\n'),
                    expectedResult: 'Document referenced flow helpers and ensure each completes without error.',
                    context: {
                        resourceType: 'flow-summary',
                        aggregated: true
                    }
                });
            }

            if (apiSummaries.size > 0) {
                const lines = [];
                apiSummaries.forEach(entry => {
                    const segments = [];
                    if (entry.endpoint) {
                        segments.push(`Endpoint: ${entry.endpoint}`);
                    }
                    if (entry.exports && entry.exports.length > 0) {
                        segments.push(`Exports: ${entry.exports.join(', ')}`);
                    }
                    if (entry.methods && entry.methods.size > 0) {
                        const methodPreview = Array.from(entry.methods.values()).slice(0, 4)
                            .map(method => {
                                const summary = method.summaryText || method.summary || '';
                                return summary ? `${method.methodName} â€” ${summary}` : method.methodName;
                            })
                            .join('; ');
                        segments.push(`Methods: ${methodPreview}${entry.methods.size > 4 ? ` (+${entry.methods.size - 4} more)` : ''}`);
                    }
                    if (entry.httpCalls && entry.httpCalls.length > 0) {
                        const preview = entry.httpCalls.slice(0, 4).map(call => `${call.method} ${call.url}`).join('; ');
                        segments.push(`HTTP: ${preview}${entry.httpCalls.length > 4 ? ` (+${entry.httpCalls.length - 4} more)` : ''}`);
                    }
                    if (entry.sqlCount) {
                        segments.push(`Database queries: ${entry.sqlCount}`);
                    }
                    const detailLine = segments.length > 0 ? ` â€” ${segments.join(' | ')}` : '';
                    lines.push(`â€¢ ${entry.label}${detailLine}`);
                });

                summarySteps.push({
                    action: ['API/page helpers invoked as part of this scenario:', lines.join('\n')].join('\n\n'),
                    expectedResult: 'Record API helper usage and validate each integration completes successfully.',
                    context: {
                        resourceType: 'api-summary',
                        aggregated: true
                    }
                });
            }

            if (httpSummaries.size > 0) {
                const lines = [];
                httpSummaries.forEach(entry => {
                    const segments = [`${entry.method} ${entry.url}`];
                    if (entry.source) {
                        segments.push(`Source: ${entry.source}`);
                    }
                    if (entry.payload) {
                        segments.push(`Payload preview: ${truncateMultiline(entry.payload, 220)}`);
                    }
                    if (entry.additionalArgs && entry.additionalArgs.length > 0) {
                        segments.push(`Additional args: ${entry.additionalArgs.join(', ')}`);
                    }
                    lines.push(`â€¢ ${segments.join(' | ')}`);
                });

                summarySteps.push({
                    action: ['External HTTP interactions detected within supporting helpers:', lines.join('\n')].join('\n\n'),
                    expectedResult: 'Verify each HTTP request returns successful status and payload meets acceptance criteria.',
                    context: {
                        resourceType: 'http-summary',
                        aggregated: true
                    }
                });
            }

            if (sqlSummaries.length > 0) {
                const lines = sqlSummaries.map(entry => {
                    const queryPreview = truncateMultiline(entry.query, 220);
                    return `â€¢ ${entry.origin}: ${queryPreview}`;
                });

                summarySteps.push({
                    action: ['Database queries executed inside flows/API helpers:', lines.join('\n')].join('\n\n'),
                    expectedResult: 'Confirm each query runs successfully and data aligns with expected state.',
                    context: {
                        resourceType: 'sql-summary',
                        aggregated: true
                    }
                });
            }

            return summarySteps;
        }

        function prepareStepsForCsv(testCase) {
            if (!testCase || !Array.isArray(testCase.steps)) {
                return [];
            }

            const primarySteps = [];
            let supportingSteps = [];

            testCase.steps.forEach(step => {
                if (isSupportingStep(step)) {
                    supportingSteps.push(step);
                } else {
                    primarySteps.push(step);
                }
            });

            // Inject API helper method steps directly into the main step list if present in supporting context
            if (testCase.supportingContext && Array.isArray(testCase.supportingContext.apis)) {
                testCase.supportingContext.apis.forEach(api => {
                    if (Array.isArray(api.methods)) {
                        api.methods.forEach((method, idx) => {
                            const methodTitle = `${method.objectName ? method.objectName + '.' : ''}${method.methodName}()`;
                            const helperLabel = api.label || 'API helper';
                            const summaryHeadline = method.summaryText || method.summary || `Execute ${methodTitle}`;
                            const functionality = method.summaryText || method.summary || 'Performs API helper operations.';
                            const parameterText = method.params || method.parameters || '';
                            const snippetPreview = method.snippet ? truncateMultiline(method.snippet, 280) : '';
                            const sections = [summaryHeadline];
                            sections.push(`Functionality: ${functionality}`);
                            sections.push(`Method call: ${methodTitle} (helper: ${helperLabel})`);
                            if (parameterText) {
                                sections.push(`Parameters: ${parameterText}`);
                            }
                            if (snippetPreview) {
                                sections.push(`Code reference:\n${snippetPreview}`);
                            }
                            const action = sections.join('\n\n');
                            const expectedResult = method.expectedResultText || method.expectedResult || 'API helper method completes successfully and returns expected data.';
                            primarySteps.push({
                                action,
                                expectedResult,
                                context: {
                                    resourceType: 'api-method',
                                    resourcePath: api.label,
                                    sequence: idx + 1,
                                    details: Object.assign({}, method, {
                                        helperLabel,
                                        summaryText: summaryHeadline,
                                        expectedResultText: expectedResult,
                                        params: parameterText,
                                        snippet: snippetPreview
                                    })
                                }
                            });
                        });
                    }
                });
            }

            const summarySteps = buildContextSummarySteps(supportingSteps, testCase.supportingContext);
            return primarySteps.concat(summarySteps);
        }

        function convertToCsv(testCases, config) {
            // Azure DevOps Test Case CSV Header - Exact required format
            const header = [
                'ID', 'Work Item Type', 'Title', 'Test Step', 'Step Action', 'Step Expected', 'Area Path', 'Assigned To', 'State'
            ];
            const rows = [header.join(',')];

            // Helper to escape CSV content (leave truly blank cells empty)
            const escapeCsv = (str) => {
                if (str === null || str === undefined || str === '') {
                    return '';
                }
                const normalized = String(str);
                const needsQuotes = /[",\n]/.test(normalized);
                const escaped = normalized.replace(/"/g, '""');
                return needsQuotes ? `"${escaped}"` : escaped;
            };

            // Helper to clean content for HTML format
            const cleanForHtml = (str) => {
                if (!str) return '';
                return str
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/\n/g, '<br/>')
                    .trim();
            };

            for (const testCase of testCases || []) {
                const preparedSteps = prepareStepsForCsv(testCase);
                if (!preparedSteps || preparedSteps.length === 0) continue;

                // Add the test case header row (no step data)
                const testCaseHeaderRow = [
                    '',
                    'Test Case',
                    escapeCsv(testCase.title),
                    '',
                    '',
                    '',
                    escapeCsv(config.areaPath || ''),
                    escapeCsv(config.assignedTo || ''),
                    escapeCsv(config.state || '')
                ];
                rows.push(testCaseHeaderRow.join(','));

                // Add each step as a separate row - ALL should be "Test Case" type
                for (let i = 0; i < preparedSteps.length; i++) {
                    const step = preparedSteps[i];
                    const stepRow = [
                        '',
                        '',
                        '',
                        (i + 1).toString(),
                        escapeCsv(step?.action || ''),
                        escapeCsv(step?.expectedResult || 'Step completes without errors.'),
                        '',
                        '',
                        ''
                    ];
                    rows.push(stepRow.join(','));
                }
            }
            return rows.join('\n');
        }

        function updateProgress(percent) {
            progressBar.style.width = percent + '%';
            progressText.textContent = percent + '%';
        }

        function showProgress() {
            progressContainer.classList.remove('hidden');
            progressContainer.classList.add('fade-in');
        }

        function hideProgress() {
            setTimeout(() => progressContainer.classList.add('hidden'), 500);
        }

        function updateStatus(message, type = 'info') {
            statusDiv.innerHTML = `<p class="fade-in ${getStatusClass(type)}">${message}</p>`;
        }

        function getStatusClass(type) {
            const classes = {
                'success': 'text-green-600 font-medium',
                'error': 'text-red-600 font-medium',
                'warning': 'text-yellow-600 font-medium',
                'info': 'text-blue-600'
            };
            return classes[type] || classes.info;
        }
    </script>
</body>
</html>
